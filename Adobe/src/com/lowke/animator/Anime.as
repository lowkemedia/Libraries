////  Anime v 1.8 - animator package//  Russell Lowke, June 30th 2013////  Copyright (c) 2006-2013 Lowke Media//  see http://www.lowkemedia.com for more information//  see http://code.google.com/p/lowke-animator/ for code repository//  see http://code.google.com/p/lowke/ for entire lowke code repository////  Permission is hereby granted, free of charge, to any person obtaining a //  copy of this software and associated documentation files (the "Software"), //  to deal in the Software without restriction, including without limitation //  the rights to use, copy, modify, merge, publish, distribute, sublicense, //  and/or sell copies of the Software, and to permit persons to whom the //  Software is furnished to do so, subject to the following conditions:// //  The above copyright notice and this permission notice shall be included in //  all copies or substantial portions of the Software.// //  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, //  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE //  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING //  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER  //  DEALINGS IN THE SOFTWARE. ////package com.lowke.animator {       import com.lowke.animator.effect.IAnimatorEffect;    import com.lowke.logger.Logger;        import flash.display.DisplayObject;    import flash.events.Event;    import flash.events.EventDispatcher;    import flash.events.IEventDispatcher;    import flash.utils.getTimer;        public class Anime extends EventDispatcher     {           // members variables        private var _animator:Animator;                         // controlling animator object        private var _target:IEventDispatcher;                   // target associated with this anime        private var _effects:Vector.<IAnimatorEffect>;          // list of Effects        private var _persist:Boolean = false;                   // if set to true then this anime is not automatically removed when                                                                 //  without Effects or by a REMOVED_FROM_STAGE event                // constants used by the rename parameter of addFX()        public static const NAMEFX_REPLACE:String       = Animator.NAMEFX_REPLACE;          // old effect is replaced with new effect        public static const NAMEFX_SNAP_REPLACE:String  = Animator.NAMEFX_SNAP_REPLACE;     // old effect snaps to end, triggering any callback, and is then replaced        public static const NAMEFX_AUTO_RENAME:String   = Animator.NAMEFX_AUTO_RENAME;      // new effect is renamed with numbered suffix so it doesn't conflict with old effect                //        // constructor        public function Anime(animator:Animator,                              target:IEventDispatcher)         {               _animator   = animator;            _target     = target;            _effects    = new Vector.<IAnimatorEffect>;                        if (_target is DisplayObject)             {                _target.addEventListener(Event.ADDED_TO_STAGE, addedToStage, false, 0, true);                _target.addEventListener(Event.REMOVED_FROM_STAGE, removedFromStage, false, 0, true);            }        }                        //        // Do everything needed to update this anime        public function update(updateTime:uint,                                forceIntervals:Boolean = false):void        {               // if there are no effects on anime then remove the anime            if (_effects.length == 0 && ! _persist)             {                remove();            }             else             {                 // iterate through effects                var effect:IAnimatorEffect;                for each (effect in _effects)                 {                    effect.resolve(updateTime, forceIntervals);                }            }        }                        private function addedToStage(evt:Event = null):void         {            update(getTimer(), true);        }                        //        // helper methods that invoke addFX()        //                // add effect to an anime, if a similar effect exists it is replaced.        public function addEffect(effect:IAnimatorEffect):IAnimatorEffect         {            return addFX(effect, NAMEFX_REPLACE);        }                // add effect to an anime that triggers on a timestamp (ts), if a similar effect exists it is replaced.        // Effect triggers on a timestamp which may be past or persent        public function addEffectTS(effect:IAnimatorEffect, ts:uint):IAnimatorEffect         {            effect.startTime = ts;            return addFX(effect, NAMEFX_REPLACE);        }                // add effect to an anime, if a similar effect exists it snaps to end triggering any callback, then is replaced.        public function snapEffect(effect:IAnimatorEffect):IAnimatorEffect         {            return addFX(effect, NAMEFX_SNAP_REPLACE);        }                // add effect to anime with a new name so it doesn't conflict with similar effects.        public function nameEffect(effect:IAnimatorEffect, name:String = null):IAnimatorEffect         {            if (! name)             {                 name = NAMEFX_AUTO_RENAME;             }                        return addFX(effect, name);        }                // add effect to anime with a new name so it doesn't conflict with similar effects.         // Effect triggers on a timestamp which may be past or persent        public function nameEffectTS(effect:IAnimatorEffect,                                      ts:uint,                                      name:String = null):IAnimatorEffect        {            effect.startTime = ts;            if (! name)             {                 name = NAMEFX_AUTO_RENAME;             }            return addFX(effect, name);        }                // add effect to anime that cycles a number of times.        public function cycleEffect(effect:IAnimatorEffect,                                     cycles:int):IAnimatorEffect         {            effect.cycles = cycles;            return addFX(effect, NAMEFX_REPLACE);        }                // add effect to anime that targets an object other than the _target of the anime it is attached to.        public function targetEffect(effect:IAnimatorEffect,                                      target:Object):IAnimatorEffect         {            // it's often desirable to target other effects on anime            if (! target)             {                throw new Error("Effect target must not be null.");            }             else if (target is String)             {                target = getEffect(target as String, false);            }                        // effect target must always be an EventDispatcher            if (! target is EventDispatcher)             {                throw new Error("Effect target must be an EventDispatcher.");            }             else             {                effect.target = target as EventDispatcher;            }                        return addFX(effect, NAMEFX_REPLACE);        }                // add effect to an anime with a precedence so it is played in a particular order.        public function precedenceEffect(effect:IAnimatorEffect,                                          precedence:int):IAnimatorEffect         {            return addFX(effect, NAMEFX_REPLACE, precedence);        }                //        // The rename string can be set to Animator.REPLACE to replace an effect with the same name        //  or Animator.AUTO_RENAME to automatically create a new and unique name for the effect        public function addFX(effect:IAnimatorEffect,                       // effect being added                              rename:String = null,                         // name of effect, null uses the default name, or use Animator.REPLACE, Animator.SNAP_REPLACE or Animator.AUTO_RENAME                              precedence:Number = NaN):IAnimatorEffect      // overrides default precedence order when effect updates        {                           //            // Renaming effect or replacing existing effect            //                        // rename effect before adding it to the anime list            //  Note: renaming efects allows you to stack effects of the same type            if (rename &&                 rename != NAMEFX_REPLACE &&                 rename != NAMEFX_SNAP_REPLACE &&                rename != NAMEFX_AUTO_RENAME)             {                effect.name = rename;            }                        // if effect with this name already exists then...            var existingEffect:IAnimatorEffect = getEffect(effect.name, false);            if (existingEffect)             {                if (rename == NAMEFX_REPLACE || rename == NAMEFX_SNAP_REPLACE)                 {                    Logger.debug("Effect \"" + effect.name + "\" being replaced on anime " + _target, Animator.DEBUG_EFFECT_BEING_REPLACED);                                        var snapReplace:Boolean = false;                    if (rename == NAMEFX_SNAP_REPLACE)                     {                        snapReplace = true;                    }                                        // ...remove existing effect so no conflict occurs                    removeEffect(existingEffect, snapReplace);                                    }                 else if (rename == NAMEFX_AUTO_RENAME)                 {                    // ...rename effect so no conflict occurs                    var counter:uint = 1;                    var newName:String;                    do                     {                        ++counter;                        newName = effect.name + "_" + counter;                    } while (getEffect(newName, false));                                        effect.name = newName;                }                 else                 {                     // can't replace existing effect                    throw new Error("Effect \"" + effect.name + "\" already exists on anime " + _target +  ".\n" +                        "Use the rename parameter of addFX() to rename your new effect so that the naming conflict does not occur.\n" +                        "The rename parameter accepts a new name, or you may set it to Animator.REPLACE,\n" +                        "to tell Animator to replace any existing effect of the same name with your new effect,\n" +                        "or Animator.AUTO_RENAME, to have Animator automatically rename your effect with a unique name if a conflict occurs.\n" +                        "Alternately, you can remove the existing effect using removeEffect() before adding your new effect.");                                        return null;                }            }                                    //            // Order of precedence            //                        // add effect to _effects list in order of precedence            var effectPrecedence:int = effect.precedence;            if (! isNaN(precedence))             {                effectPrecedence = precedence;            }                        var nEffects:uint = _effects.length;            for (var i:uint = 0; i < nEffects; ++i)             {                if (effectPrecedence < _effects[i].precedence)                 {                    break;                }            }            _effects.splice(i, 0, effect);                        //            // initialize and resolve            //            effect.initialize(_animator, this, effectPrecedence);            effect.resolve(getTimer(), true);                        return effect;        }                        //        // get effect from effects list by name        public function getEffect(effectName:String,                                   giveWarning:Boolean = true):IAnimatorEffect         {            for each (var effect:IAnimatorEffect in _effects)             {                if (effect.name == effectName)                 {                    return effect;                }            }                        if (giveWarning)             {                Logger.warning("Could not find effect \"" + effectName + "\" on " + _target + ".\n" +                    "Effects that were found were the following: " + dumpEffects() + ".", Animator.WARNING_CANT_FIND_EFFECT);            }                        return null;        }                        //        // remove any effects containing str in name        //  if no str passed then clear effects        public function removeEffects(str:String = null,                                       snapToEnd:Boolean = false):void         {               if (! str)             {                clearEffects(snapToEnd);            }             else             {                for each (var effect:IAnimatorEffect in _effects)                 {                    if (effect.name.indexOf(str) != -1)                     {                        removeEffect(effect, snapToEnd);                    }                }            }        }                        public function removeEffectNamed(effectName:String,                                           snapToEnd:Boolean = false,                                          giveWarning:Boolean = true):void         {            var effect:IAnimatorEffect = getEffect(effectName, giveWarning);            if (effect)             {                removeEffect(effect, snapToEnd);            }        }                //        // remove specific effect        public function removeEffect(effect:IAnimatorEffect,                                      snapToEnd:Boolean = false,                                      giveWarning:Boolean = true):void         {            // ensure effect in effects list            var index:int = _effects.indexOf(effect);            if (index != -1)             {                if (snapToEnd)                 {                    effect.snapToEnd();                    effect.dispatchEffectDone();                }                                // have the effect cleanup anything it has added                effect.cleanup();                                // effect.remove() can change the _effects list,                 //  so index must be recalculated.                index =  _effects.indexOf(effect);                                // delete from _effects list                _effects.splice(index, 1);                            }             else if (giveWarning)             {                Logger.warning("Could not remove effect \"" + effect.name + "\" on " + _target + ".\n" +                    "Effects that were found were the following: " + dumpEffects() + ".", Animator.WARNING_CANT_REMOVE_EFFECT);            }        }                        //        // snap all effects to end, this will cause them to end when updated,        //  resulting in callbacks to be triggered.        public function snapToEnd():void         {               for each (var effect:IAnimatorEffect in _effects)             {                effect.snapToEnd();            }        }                        //        // clear all effects on this anime        public function clearEffects(snapToEnd:Boolean = false):void         {               // remove all effects            while (_effects.length)             {                removeEffect(_effects[0], snapToEnd);            }        }                /**         *  close() is consistent with other utilities such as ButtonController and          *      PlayFrames, though it's the same as calling remove()         */        public function close():void         {            remove();        }                //        // remove this anime        public function remove():void         {               // make sure event listeners are removed            if (_target is DisplayObject)             {                _target.removeEventListener(Event.ADDED_TO_STAGE, addedToStage);                _target.removeEventListener(Event.REMOVED_FROM_STAGE, removedFromStage);            }                        // tell Animator to delete reference            _animator.removeInternal(_target);        }        private function removedFromStage(evt:Event = null):void         {            if (! _persist)             {                Logger.debug("DisplayObject " + _target + " " + (_target as DisplayObject).name + " removed from Animator as it was removed from stage. Set persist to true to prevent this.",                    Animator.DEBUG_REMOVED_FROM_STAGE);                remove();            }        }                //        // not only remove the anime but remove its target DisplayObject        //  from the parent display, removing it from the screen        public function destroy():void         {            remove();            if (_target is DisplayObject)             {                var dObj:DisplayObject = _target as DisplayObject;                if (dObj.parent)                 {                    dObj.parent.removeChild(dObj);                }            }        }                        //        // pause all effects on this anime        public function pause():void         {            for each (var effect:IAnimatorEffect in _effects)             {                effect.pause();            }        }                        //        // unpause all effects on this anime        public function unpause():void         {            for each (var effect:IAnimatorEffect in _effects)             {                effect.unpause();            }        }                        //        // print anime with list of effects        public override function toString():String         {            return _target +  " effects:" + dumpEffects() + "\n";        }                public function dumpEffects():String         {               var nEffects:uint = _effects.length;            if (nEffects == 0)             {                return "[ none ]";            }                        // iterate through effects            var str:String = "";            for (var i:uint = 0; i < nEffects; ++i)             {                if (i == 0)                 {                     str += "[ ";                 }                str += _effects[i];                str += (i == (nEffects - 1)) ? " ]" : ", ";            }                        return str;        }                        //        //        // accessors and mutators        //        public function get target():IEventDispatcher       { return _target; }        public function get persist():Boolean               { return _persist; }                public function set persist(val:Boolean):void       { _persist = val; }    }}