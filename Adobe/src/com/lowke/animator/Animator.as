////  Animator v 1.8- animator package//  Russell Lowke, June 30th 2013////  Copyright (c) 2006-2013 Lowke Media//  see http://www.lowkemedia.com for more information//  see http://code.google.com/p/lowke-animator/ for code repository//  see http://code.google.com/p/lowke/ for entire lowke code repository////  Permission is hereby granted, free of charge, to any person obtaining a //  copy of this software and associated documentation files (the "Software"), //  to deal in the Software without restriction, including without limitation //  the rights to use, copy, modify, merge, publish, distribute, sublicense, //  and/or sell copies of the Software, and to permit persons to whom the //  Software is furnished to do so, subject to the following conditions:// //  The above copyright notice and this permission notice shall be included in //  all copies or substantial portions of the Software.// //  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, //  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE //  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING //  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER  //  DEALINGS IN THE SOFTWARE. ////package com.lowke.animator{       import com.lowke.animator.event.RemovedEvent;        import flash.display.Shape;    import flash.events.Event;    import flash.events.EventDispatcher;    import flash.events.IEventDispatcher;    import flash.events.TimerEvent;    import flash.geom.Point;    import flash.utils.Dictionary;    import flash.utils.Timer;    import flash.utils.getTimer;        /**     * Animator. A multipurpose animator for Flash.     *      * @author Russell Lowke     * @langversion ActionScript 3.0     * @playerversion Flash 10     * @see http://www.lowkemedia.com     */    public class Animator extends EventDispatcher     {           //        // static reference to Animator singleton        private static var _instance:Animator;                //        // constants                //        // error, warning and ifo IDs        public static const LOG_PREFIX:String                          = "ANI";        public static const WARNING_CANT_FIND_EFFECT:String            = "ANI00";        public static const WARNING_CANT_REMOVE_EFFECT:String          = "ANI01";        public static const WARNING_CANT_FIND_STAGE:String             = "ANI02";        public static const WARNING_SNAP_TO_END_NOT_SUPPORTED:String   = "ANI03";        public static const WARNING_CYCLE_NOT_SUPPORTED:String         = "ANI04";        public static const WARNING_REVERSE_NOT_SUPPORTED:String       = "ANI05";        public static const WARNING_PAUSE_NOT_SUPPORTED:String         = "ANI06";        public static const WARNING_UNPAUSE_NOT_SUPPORTED:String       = "ANI07";        public static const DEBUG_REMOVED_FROM_STAGE:String            = "ANI08";        public static const DEBUG_EFFECT_BEING_REPLACED:String         = "ANI09";                        // used for the last parameter "type" of constructor for most Effects,         //  used to tell Effect what to do on conclusion        public static const TYPE_PERSIST:uint           = 0;                // leave effect in place        public static const TYPE_END:uint               = 1;                // end effect by removing effect from the anime        public static const TYPE_REMOVE:uint            = 2;                // remove anime along with all effects on it, ending all effects        public static const TYPE_DESTROY:uint           = 3;                // remove anime AND remove its target DisplayObject from the parent        public static const TYPE_CYCLE:uint             = 4;                // cycle effect back to the beginning        public static const TYPE_REVERSE:uint           = 5;                // reverse the effect/play effect backwards        public static const TYPE_PAUSE:uint             = 6;                // pause effect until furthur notice (not currently supported)                // used for rename parameter of addFX() in Anime.as        //  Note: rename may instead be set to a string to rename the Effect to        public static const NAMEFX_REPLACE:String       = "replace";        // old effect is replaced with new effect        public static const NAMEFX_SNAP_REPLACE:String  = "snapReplace";    // old effect snaps to end, triggering any callback, and is then replaced        public static const NAMEFX_AUTO_RENAME:String   = "rename";         // new effect is renamed with numbered suffix so it doesn't conflict with old effect                // used for precedence parameter of addFX() in Anime.as        //  Note: precedence can be set to any int, not just these        public static const PRECEDENCE_FIRST:int        = 0;        public static const PRECEDENCE_SECOND:int       = 10;        public static const PRECEDENCE_THIRD:int        = 20;        public static const PRECEDENCE_LATER:int        = 30;        public static const PRECEDENCE_LAST:int         = 40;                // used for interval parameter on an effect        //  Note: interval can be set to ANY uint, not just these        public static const INTERVAL_NONE:uint                      = 0;        public static const INTERVAL_QUARTER_SECOND:uint            = 250;        public static const INTERVAL_THIRD_OF_A_SECOND:uint         = 333;        public static const INTERVAL_HALF_SECOND:uint               = 500;        public static const INTERVAL_TWO_THIRDS_OF_A_SECOND:uint    = 666;        public static const INTERVAL_WHOLE_SECOND:uint              = 1000;                        // a static _ticker is used to listen for ENTER_FRAME events        private static var _ticker:Shape = new Shape();                        //        // member variables                private var _animeDict:Dictionary;      // dictionary of anime objects, for fast lookup        private var _animeVect:Vector.<Anime>;  // vector of anime objects, for fast iteration        private var _updateTime:uint;           // time when update was called        private var _timePassed:int;            // time between updates        private var _timer:Timer;               // timer object used for interval based update events        private var _timeCap:uint;              // maximum timePassed allowed for an update, if 0 then there is no timeCap                //        // constructor                /**         * Animator is a singleton and should never be constructed directly.         * Use Animator.instance to obtain a reference to the AssetLoader.         */        public function Animator()         {            super();                        if (_instance != null)             {                // error to prevent new instances of AssetLoader being created.                throw new Error("Animator is a singleton, it should never be created twice.\n" +                    "Use Animator.instance to get a reference to Animator.");            }                        // create a dictonary hash map for anime            _animeDict = new Dictionary(true);            _animeVect = new Vector.<Anime>;            _timeCap = 250;                 // default timecap of 1/4 of a second                        // update whenever ENTER_FRAME is called            _ticker.addEventListener(Event.ENTER_FRAME, doUpdate, false, 0, true);        }                     /**         * <p>Returns an anime instance linked to the target. If one does not exist yet then one is created.         * anime() is typically used to create and get Anime objects.         * The target EventDispatcher is usually (but not always) DisplayObject of some sort, often a Sprite or MovieClip.</p>         *          * <p>Note: Anime instances without any Effects attached will automatically be removed on the next update().         * Similarly, anime instances which have a target DisplayObject that is removed from stage will also be automatically removed.           * To prevent this set the Anime's _persist flag to true.</p>         *          * @param target Target object that anime is linked to. Target must be an EventDispatcher and is usually a DisplayObject         *          * @return Returns an Anime instance linked to the target. If one does not yet exist then one is created.         *          * @see #getAnime()         */        public function anime(target:IEventDispatcher):Anime         {               if (! target)             {                throw new Error("anime() received a null target./r");            }                        // try to get the anime            var anime:Anime = _animeDict[target];                        // if anime not found...            if (! anime)             {                // ...then create a new anime                anime = new Anime(this, target);                _animeDict[target] = anime;                _animeVect.push(anime);            }                        return anime;        }                // convenience static accessor to anime()        public static function anime(target:IEventDispatcher):Anime         {            return Animator.instance.anime(target);        }                /**         * Returns the Anime object linked to the target, if any.         * Unlike anime(), if no such Anime object exists then it is not automatically created and <code>null</code> is returned.         * getAnime() is useful for verifying if an Anime linked to the target exists yet.         *          * @param target Target object that anime is linked to.         *          * @see #anime()         */         public function getAnime(target:EventDispatcher):Anime         {            return _animeDict[target];        }                /**         * Updates all Anime objects in Animator, performing all effects attached to them.         *          * @param forceIntervals If true then the update is performed on each Anime resetting any interval.         */         public function update(forceIntervals:Boolean = false):void         {            doUpdate(null, forceIntervals);        }                private function doUpdate(event:Event = null,                                  forceIntervals:Boolean = false):void         {               var updateTime:uint = getTimer();            _timePassed = updateTime - _updateTime;            _updateTime = updateTime;                        // iterate through each anime            var anime:Anime;            for each (anime in _animeVect)             {                anime.update(_updateTime, forceIntervals);            }        }                private function updateTimerEvent(event:TimerEvent):void        {            doUpdate(event);            event.updateAfterEvent();        }                /**         *  close() is consistent with other utilities such as ButtonController and          *      PlayFrames, though it's the same as calling remove()         */        public function close(target:IEventDispatcher):void         {            remove(target);        }                /**         * Removes (deletes) any anime from _animeDict that's linked to the target.         *          * @param target Target object linked to Anime that is to be removed.         */         public function remove(target:IEventDispatcher):void         {               var anime:Anime = _animeDict[target];            if (anime)             {                anime.remove();            }        }                //        // delete an anime from Animator list, as called from Anime.as        internal function removeInternal(target:IEventDispatcher):void         {               var anime:Anime = _animeDict[target];            if (anime)             {                anime.clearEffects();                _animeDict[target] = null;                delete _animeDict[target];                                var index:uint = _animeVect.indexOf(anime);                _animeVect.splice(index, 1);                                // dispatch event declaring Anime being removed                var removedEvent:RemovedEvent = new RemovedEvent(RemovedEvent.ANIME_REMOVED_EVENT, target);                target.dispatchEvent(removedEvent);                dispatchEvent(removedEvent);            }        }                        /**         * Clears all Anime in Animator         */         public function clear():void         {            for each (var i:Anime in _animeVect)             {                remove(i.target);            }        }                        /**         * Pauses all Anime in Animator         */         public function pause():void         {            for each (var i:Anime in _animeVect)             {                i.pause();            }        }                        /**         * Unpauses all Anime in Animator         */         public function unpause():void         {            for each (var i:Anime in _animeVect)             {                i.unpause();            }        }                        /**         * @return Returns a String with a description of all Anime in Animator         */         public function dump():String         {            var str:String = "";                        // iterate through each anime            for each (var i:Anime in _animeVect)             {                str += i;            }                        return str;         }                /**         * @see #dump()         */         public override function toString():String         {            return dump();        }                        //        // accessors and mutators        //                /** Gives a reference to the Animator singleton. */        public static function get instance():Animator          {             if (! _instance)             {                _instance = new Animator();            }            return _instance;         }                /** The last updateTime, in milliseconds. */        public function get updateTime():uint        {             return _updateTime;        }                /** Amount of time passed between last update, in milliseconds. */        public function get timePassed():int        {             return _timePassed;         }                /** Time cap to maximum time passes between updates, in milliseconds. */        public function get timeCap():uint        {             return _timeCap;         }                /** Returns a generic Anime to which effects can be attached without being associated with a specific target. */        public function get generic():Anime        {             return anime(_ticker);         }                        public function set timeCap(val:uint):void        {             _timeCap  = val;         }                /**          * Tells Animator to update at a specific interval (in milliseconds) as well as at the frame rate.         * This is really only useful if Animator needs to update more frequently than the frame rate.         * Unfortuantely interval timers do not yield absolutely consistant updates on the interval.         * Such intervals were more popular under AS2 and use to perform better.         *          * @param interval Interval at which Animator will call update().         */        public function set interval(interval:uint):void         {            if (interval == 0)             {                // remove timer                if (_timer)                 {                    _timer.removeEventListener(TimerEvent.TIMER, updateTimerEvent);                }                _timer.stop();      // must stop a timer before clearing it                _timer = null;            }             else             {                // create and start timer                _timer  = new Timer(interval);                _timer.addEventListener(TimerEvent.TIMER, updateTimerEvent, false, 0, true);                _timer.start();            }        }    }}