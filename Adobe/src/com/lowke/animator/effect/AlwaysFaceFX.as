////  AlwaysFaceFX v 1.0.2 - animator package//  Russell Lowke, June 1st 2011////  Copyright (c) 2008-2011 Lowke Media//  see http://www.lowkemedia.com for more information//  see http://code.google.com/p/lowke-animator/ for code repository////  Permission is hereby granted, free of charge, to any person obtaining a //  copy of this software and associated documentation files (the "Software"), //  to deal in the Software without restriction, including without limitation //  the rights to use, copy, modify, merge, publish, distribute, sublicense, //  and/or sell copies of the Software, and to permit persons to whom the //  Software is furnished to do so, subject to the following conditions:// //  The above copyright notice and this permission notice shall be included in //  all copies or substantial portions of the Software.// //  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, //  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE //  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING //  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER  //  DEALINGS IN THE SOFTWARE. ////package com.lowke.animator.effect{    import com.lowke.animator.Animator;    import com.lowke.util.NumberUtil;    import flash.display.DisplayObject;        public class AlwaysFaceFX extends AnimatorEffect implements IAnimatorEffect     {           private var _motionDObject:DisplayObject;           // moving object being listened to to determine rotation        private var _turningDObj:DisplayObject;             // object that actually turns,         //  sometimes this is different form the anime target        private var _angularVelocity:Number;                // degrees per tick target turns at        private var _dObj:DisplayObject;                    // target must be a DisplayObject        private var _xOffset:Number;                        // x offset to _motionDObject        private var _yOffset:Number;                        // y offset to _motionDObject        private var _targetRotation:Number = NaN;           // target rotation being rotated to        private var _rotation:Number;                       // last rotation                // accessing an external static references, such as Animator, has an overhead,        //  so, for performance sake, external vars are substituted with local references        public static const TYPE_PERSIST:uint       = Animator.TYPE_PERSIST;        public static const PRECEDENCE_LAST:int     = Animator.PRECEDENCE_LAST;        public static const INTERVAL_NONE:uint      = Animator.INTERVAL_NONE;                        // automatically rotates display object to face direction it's moving        public function AlwaysFaceFX(motionDObject:DisplayObject,               // object being listened to for motion                                     angularVelocity:Number = 0,                // maximum angular velocity                                     turningDObject:DisplayObject = null,       // sometimes the turning object is not the target                                            xOffset:Number = 0, yOffset:Number = 0)    // sometimes an offset is needed on the motionDObject        {               super("AlwaysFaceFX",                 TYPE_PERSIST,                 PRECEDENCE_LAST,            // this effect plays last after the target has moved                INTERVAL_NONE);                        _motionDObject = motionDObject;            _angularVelocity = angularVelocity;            _turningDObj = turningDObject;            _xOffset = xOffset;            _yOffset = yOffset;        }                public override function activate():void         {               if (_target is DisplayObject)             {                _dObj = _target as DisplayObject;            }             else             {                throw new Error("AlwaysFaceFX effect must have a target of type DisplayObject");            }                        if (! _turningDObj)             {                _turningDObj = _dObj;            }                        // set at starting rotation, if any            _rotation = _turningDObj.rotation;                    }                public override function update():Boolean         {            var x:Number = (_motionDObject.x + _xOffset) - _dObj.x;            var y:Number = (_motionDObject.y + _yOffset) - _dObj.y;                        _targetRotation = NumberUtil.XYToAngle(x, y);                        if (! isNaN(_targetRotation) && _rotation != _targetRotation)             {                if (_angularVelocity)                 {                    var mod:int = incOrDec(_rotation, _targetRotation, 360);                    _rotation = cleanAngle(_rotation + _angularVelocity*_timePassed*mod);                                        // check if overshot target                    if (incOrDec(_rotation, _targetRotation, 360) == 0 - mod)                     {                         _rotation = _targetRotation;                     }                }                 else                 {                    _rotation = _targetRotation;                }                                _turningDObj.rotation = _rotation;                                if (_rotation == _targetRotation)                 {                    // once target rotation reached, clear it                    _targetRotation = NaN;                }            }                        return false;        }                public static function cleanAngle(angle:Number):Number         {            angle %= 360;            if (angle < 0)             {                 return 360 + angle;             }            return angle;        }                //        // given a looping sequence in both directions with a range of max        // if at n which direction (+ or -) is quickest to get to dest        public static function incOrDec(n:uint, dest:uint, max:uint):int         {            // ensure integers                        var inc:int = 0;            var dec:int = 0;                        if (n == dest)             {                return 0;            }             else if (n < dest)             {                inc = dest - n;                dec = n + (max - dest);            }             else if (n > dest)             {                inc = dest + (max - n);                dec = n - dest;            }                        if (inc > dec)             {                return -1;            }             else             {                return +1;            }        }                public function get xOffset():Number                    { return _xOffset; }        public function get yOffset():Number                    { return _yOffset; }        public function get angularVelocity():Number            { return _angularVelocity; }                public function set xOffset(val:Number):void            { _xOffset = val; }        public function set yOffset(val:Number):void            { _yOffset = val; }        public function set angularVelocity(val:Number):void    { _angularVelocity = val; }    }}