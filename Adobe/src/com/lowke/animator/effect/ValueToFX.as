////  ValueToFX v 1.3 - animator package//  Russell Lowke, October 22nd 2010////  Copyright (c) 2008-2010 Lowke Media//  see http://www.lowkemedia.com for more information//  see http://code.google.com/p/lowke-animator/ for code repository////  Permission is hereby granted, free of charge, to any person obtaining a //  copy of this software and associated documentation files (the "Software"), //  to deal in the Software without restriction, including without limitation //  the rights to use, copy, modify, merge, publish, distribute, sublicense, //  and/or sell copies of the Software, and to permit persons to whom the //  Software is furnished to do so, subject to the following conditions:// //  The above copyright notice and this permission notice shall be included in //  all copies or substantial portions of the Software.// //  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, //  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE //  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING //  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER  //  DEALINGS IN THE SOFTWARE. ////package com.lowke.animator.effect{    import com.lowke.animator.Animator;        public class ValueToFX extends AnimatorEffect implements IAnimatorEffect     {           private var _variable:String;               // name of variable being changed        private var _start:Number;                  // starting value        private var _end:Number;                    // ending value        private var _range:Number;                  // difference between the begin and finish values        private var _endTime:uint;                  // ending time        private var _duration:uint;                 // duration of animation        private var _changeTime:Number;             // duration time of the change        private var _accelerate:Boolean;            // if true then acceleration used, otherwise deceleration        private var _stackTween:Boolean;            // if true tween will stack with others        private var _value:Number;                  // value for variable being stacked                // accessing an external static references, such as Animator, has an overhead,        //  so, for performance sake, external vars are substituted with local references        public static const TYPE_END:uint           = Animator.TYPE_END;        public static const PRECEDENCE_FIRST:int    = Animator.PRECEDENCE_FIRST;        public static const INTERVAL_NONE:uint      = Animator.INTERVAL_NONE;                        //  Diffusion Approximation used to accelerate or decelerate change in a variable        //                        public function ValueToFX(variable:String,                                  start:Number,                                  end:Number,                                  duration:Number,                                  changeTime:Number,                                  accelerate:Boolean = false,                                  stackTween:Boolean = false,                                  type:uint = TYPE_END)         {               super("ToValueFX_" + variable, type, PRECEDENCE_FIRST, INTERVAL_NONE);                        _variable   = variable;            _start      = start;            _end        = end;            _duration   = duration;            _changeTime = changeTime;            _accelerate = accelerate;            _stackTween = stackTween;        }                public override function activate():void         {               _value     = _target[_variable];            if (isNaN(_start))             {                _start = _value;            }                        if (isNaN(_end))             {                _end = _value;            }                        _range     = _end - _start;            _endTime   = _updateTime + _duration;         }                public override function update():Boolean         {               var nVal:Number;            if (_updateTime >= _endTime)             {                if (_stackTween)                 {                    valueTo(_end);                }                 else                 {                    _target[_variable] = _end;                }                return true;            }             else             {                                //  Diffusion Approximation compliments of John J Lowke                //   "The LTE Diffusion approximation" in calculating properties of welding arcs.                //  Local Thermodynamic Equilibrium (LTE)                                if (_accelerate)                 {                    // change performed at end of animation                    // OLD:    this.value = _end - _range*(1 - Math.pow(Math.E, (_updateTime - _endTime)/_changeTime));                                        nVal = _end - _range*(1 - Math.pow(Math.E, (_updateTime - _endTime)/_changeTime))/                        (1 - Math.pow(Math.E, (-_endTime)/_changeTime));                    if (_stackTween)                     {                        valueTo(nVal);                    }                     else                     {                        _target[_variable] = nVal;                    }                }                 else                 {                     // change performed at beginning of animation                    // OLD:    this.value = _start + _range*(1 - Math.pow(Math.E, (_startTime - _updateTime)/_changeTime));                                        nVal = _start + _range*(1 - Math.pow(Math.E, (_startTime - _updateTime)/_changeTime))/                        (1 - Math.pow(Math.E, (-_endTime)/_changeTime));                    if (_stackTween)                     {                        valueTo(nVal);                    }                     else                     {                        _target[_variable] = nVal;                    }                }                                return false;            }        }                //        // used for stacking tweens        public function valueTo(n:Number):void         {               // Change target variable only by the change in n            // This way tween effects can stack, even though they target the same variable            var nValue:Number = _target[_variable] + (n - _value);            _target[_variable] = nValue;                        // Flash introduces a rounding error with variables such as x, y, and alpha            // This error needs to be factored in            var err:Number = _target[_variable] - nValue;            _value = n + err;        }                //        // accessors and mutators        //                public function get variable():String       { return _variable; }        public function get value():Number          { return _value; }    }}// to Zero   this.value = _startVal*(1 - Math.pow(Math.E, (_updateTime - _endTime)/_tDecelOver));// to Value  this.value = _value*(1 - Math.pow(Math.E, (_startTime - _updateTime)/_changeTime));// var vel:Number = _startVal*(1 - Math.pow(Math.E, (_updateTime-_endTime)/_tDecelOver) - Math.pow(Math.E, (_startTime - _updateTime)/_tAccel)));