package com.lowke.animator.effect.path.geometry{    /**     * http://en.nicoptere.net/     * @author nicoptere     */        import flash.geom.Point;        public class Spline     {        static public var _precision:Number = .1;                /**         * calculates the cubic spline passing through the handles         * @param   handles a Vector of the key points to smooth         * @param   loop wether the curve should loop default false         * @param   precision a Number between Number.MIN_VALUE (extremely precise ) and 1 (coarse) default is 0.1 I recomend not to go under 0.01         * @return an array of smoothed points         */        static public function CubicPath(handles:Vector.<Point>,                                          loop:Boolean = false,                                          precision:Number =.1 ):Vector.<Point>        {                        //curve's smoothness             _precision = precision;                        if ( loop )             {                handles.shift();                handles.pop();            }                        //output values            var tmp:Vector.<Point> = new Vector.<Point>();                        var i:int = 0;                        var p0:Point = new Point(0,0);            var p1:Point = new Point(0,0);            var p2:Point = new Point(0,0);                        while(i < handles.length)             {                //p0                if(i == 0)                 {                    if ( loop == true )                     {                        p0.x = (handles[handles.length - 1].x + handles[i].x)/2;                        p0.y = (handles[handles.length - 1].y + handles[i].y)/2;                    }                     else                     {                        p0.x = handles[i].x;                        p0.y = handles[i].y;                    }                }                 else                 {                    p0.x = ( handles[i - 1].x + handles[i].x ) / 2;                    p0.y = ( handles[i - 1].y + handles[i].y ) / 2;                }                                //p1                p1.x = handles[i].x;                p1.y = handles[i].y;                                //p2                    if( i == handles.length - 1 )                 {                    if (loop == true)                     {                        p2.x = (handles[i].x + handles[0].x) / 2;                        p2.y = (handles[i].y + handles[0].y) / 2;                    }                     else                     {                        p2.x = handles[i].x;                        p2.y = handles[i].y;                    }                }                 else                 {                    p2.x = (handles[i + 1].x + handles[ i ].x ) / 2;                    p2.y = (handles[i + 1].y + handles[ i ].y ) / 2;                }                                var t:Number;                var t2:Number;                var t3:Number;                var t4:Number;                var X:Number;                var Y:Number;                                var j:Number = 0;                while(j < 1)                 {                    t  = 1 - j;                    t2 = t * t;                    t3 = 2 * j * t;                    t4 = j * j;                                        X = t2 * p0.x + t3 * p1.x + t4 * p2.x;                    Y = t2 * p0.y + t3 * p1.y + t4 * p2.y;                                        tmp.push( new Point( X, Y ) );                    j += _precision;                }                i++;            }            return tmp;        }                static public function QuadraticBezier(t:Number, p0:Point, p1:Point, p2:Point, p3:Point): Point        {            var X:Number = p0.x * Math.pow((1 - t), 3);             X += 3 * p1.x * t * Math.pow((1 - t), 2);            X += 3 * p2.x * ( t * t ) * (1 - t);            X += p3.x * ( t*t*t );                        var Y:Number = p0.y * Math.pow((1 - t), 3);             Y += 3 * p1.y * t * Math.pow((1 - t), 2);            Y += 3 * p2.y * ( t * t ) * ( 1 - t);            Y += p3.y * ( t*t*t );                        return new Point( X, Y );        }                        static public function CubicBezier(t:Number, p0:Point, p1:Point, p2:Point): Point        {            var X:Number = p0.x * ( (1 - t) * (1 - t) );             X += 2 * t * ( 1 - t ) * p1.x;            X += p2.x * ( t * t );                        var Y:Number = p0.y * ( (1 - t) * (1 - t) );             Y += 2 * t * ( 1 - t ) * p1.y;            Y += p2.y * ( t * t );                        return new Point( X, Y );        }    }}