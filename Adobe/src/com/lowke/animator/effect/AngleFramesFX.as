////  AngleFramesFX v 1.1 - animator package//  Russell Lowke, October 20th 2010////  Copyright (c) 2008-2010 Lowke Media//  see http://www.lowkemedia.com for more information//  see http://code.google.com/p/lowke-animator/ for code repository////  Permission is hereby granted, free of charge, to any person obtaining a //  copy of this software and associated documentation files (the "Software"), //  to deal in the Software without restriction, including without limitation //  the rights to use, copy, modify, merge, publish, distribute, sublicense, //  and/or sell copies of the Software, and to permit persons to whom the //  Software is furnished to do so, subject to the following conditions:// //  The above copyright notice and this permission notice shall be included in //  all copies or substantial portions of the Software.// //  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, //  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE //  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING //  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER  //  DEALINGS IN THE SOFTWARE. ////package com.lowke.animator.effect{    import com.lowke.animator.Animator;    import com.lowke.animator.Anime;    import com.lowke.util.NumberUtil;        import flash.display.MovieClip;        public class AngleFramesFX extends AnimatorEffect implements IAnimatorEffect    {           private var _cycleSize:uint;            // number of images in cycle        private var _frame:Number;              // image cell currently displayed        private var _targetAngle:Number;        // desired angle        private var _angle:Number;              // current angle        private var _angularVelocity:Number;    // degrees per tick this thing turns at        private var _movieClip:MovieClip;       // target must be of type MovieClip                // accessing an external static references, such as Animator, has an overhead,        //  so, for performance sake, external vars are substituted with local references        public static const TYPE_PERSIST:uint       = Animator.TYPE_PERSIST;        public static const PRECEDENCE_FIRST:int    = Animator.PRECEDENCE_FIRST;        public static const INTERVAL_NONE:uint      = Animator.INTERVAL_NONE;                // startAngle and targetAngle are in degrees        public static function turnInDuration(duration:uint,                                              startAngle:Number,                                              targetAngle:Number):AngleFramesFX         {            var angle:Number = NumberUtil.cleanAngle(targetAngle - startAngle);            if (angle > 180)             {                 angle = 360 - angle;            }            var angularVelocity:Number = angle/duration;            return new AngleFramesFX(angularVelocity, startAngle, targetAngle);        }                // startAngle and targetAngle are in degrees        public function AngleFramesFX(angularVelocity:Number,                                      startAngle:Number = 0,                                      targetAngle:Number = 0)         {               super("AngleFramesFX", TYPE_PERSIST, PRECEDENCE_FIRST, INTERVAL_NONE);                        _angularVelocity = angularVelocity;            _angle = startAngle;            _targetAngle = targetAngle;        }                public override function activate():void         {               // _target must be a MovieClip            if (_target is Anime)             {                _target = (_target as Anime).target;            }                        if (_target is MovieClip)             {                _movieClip = _target as MovieClip;            }             else             {                throw new Error("AngleFramesFX effect must have a target of type MovieClip");            }                        _cycleSize       = _movieClip.totalFrames;            _frame           = _movieClip.currentFrame;        }                public override function update():Boolean         {            var mod:int = NumberUtil.incOrDec(_angle, _targetAngle, 360);            _angle = NumberUtil.cleanAngle(_angle + _angularVelocity * _timePassed * mod);                        // check if overshot target            if (NumberUtil.incOrDec(_angle, _targetAngle, 360) == 0 - mod)            {                 _angle = _targetAngle;             }                        // set the angle frame for the target            _frame = angleToCell(_angle, _cycleSize);            _movieClip.gotoAndStop(Math.round(_frame));                        if (_angle == _targetAngle)             {                return true;            }             else             {                return false;            }        }                public override function snapToEnd():void         {            _angle = _targetAngle;            _frame = angleToCell(_angle, _cycleSize);            _movieClip.gotoAndStop(Math.round(_frame));        }                //        // convert angle (degrees) to an animation cell number        public static function angleToCell(angle:Number, totalCells:uint):uint         {               // find angle size of each segment            var segment:Number = 360.0 / totalCells;                        // augment the angle by half a segment            angle += segment/2;                        // loop at 360 back to 0 degrees            if (angle >= 360)             {                 angle -= 360;             }                        // find the cell            var cell:uint = Math.floor(angle/segment) + 1;                        return cell;        }                public function get angle():Number                      { return _angle; }        public function get targetAngle():Number                { return _targetAngle; }        public function get angularVelocity():Number            { return _angularVelocity; }            public function set angle(val:Number):void        {            _angle = NumberUtil.cleanAngle(val);        }            public function set targetAngle(val:Number):void        {            _targetAngle = NumberUtil.cleanAngle(val);        }        public function set angularVelocity(val:Number):void    { _angularVelocity = val; }    }}