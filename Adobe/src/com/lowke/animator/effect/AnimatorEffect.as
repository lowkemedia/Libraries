////  AnimatorEffect v 1.4 - animator package//  Russell Lowke, June 30th 2013////  Copyright (c) 2009-2013 Lowke Media//  see http://www.lowkemedia.com for more information//  see http://code.google.com/p/lowke-animator/ for code repository//  see http://code.google.com/p/lowke/ for entire lowke code repository////  Permission is hereby granted, free of charge, to any person obtaining a //  copy of this software and associated documentation files (the "Software"), //  to deal in the Software without restriction, including without limitation //  the rights to use, copy, modify, merge, publish, distribute, sublicense, //  and/or sell copies of the Software, and to permit persons to whom the //  Software is furnished to do so, subject to the following conditions:// //  The above copyright notice and this permission notice shall be included in //  all copies or substantial portions of the Software.// //  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, //  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE //  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING //  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER  //  DEALINGS IN THE SOFTWARE. ////package com.lowke.animator.effect{    import com.lowke.animator.Animator;    import com.lowke.animator.Anime;    import com.lowke.animator.event.EffectEvent;    import com.lowke.logger.Logger;        import flash.events.Event;    import flash.events.EventDispatcher;    import flash.events.IEventDispatcher;    import flash.utils.getTimer;        public class AnimatorEffect extends EventDispatcher implements IAnimatorEffect     {           private static const DONT_CYCLE:int = 0;    // indicates this effect doesn't cycle                protected var _name:String;                 // name of this effect        protected var _animator:Animator;           // animator        protected var _anime:Anime;                 // anime object owning the effect        protected var _target:IEventDispatcher;     // target object being affected        protected var _type:uint;                   // effect type, NONE, END, REVERSE, CYCLE, or DESTROY        protected var _precedence:int;              // order in which effect is processed, for convenience is         //                                          //  usually Animator.FIRST, Animator.LATER or Animator.LAST,         //                                          //  but can be any int if a larger range is needed        protected var _interval:uint = 0;           // interval at which effect will trigger, 0 = every update        protected var _startTime:uint;              // time effect starts, might be time-stamped future or past time        protected var _updateTime:uint;             // time of update        protected var _timePassed:int;              // time between updates        protected var _cycles:int = DONT_CYCLE;     // # of cycles before ending effect        protected var _activated:Boolean;           // if false effect has not been activated yet                // accessing an external static references, such as Animator, has an overhead,        //  so, for performance sake, external vars are substituted with local references        public static const TYPE_PERSIST:uint   = Animator.TYPE_PERSIST;        public static const TYPE_END:uint       = Animator.TYPE_END;        public static const TYPE_REMOVE:uint    = Animator.TYPE_REMOVE;        public static const TYPE_DESTROY:uint   = Animator.TYPE_DESTROY;        public static const TYPE_CYCLE:uint     = Animator.TYPE_CYCLE;        public static const TYPE_REVERSE:uint   = Animator.TYPE_REVERSE;        public static const TYPE_PAUSE:uint     = Animator.TYPE_PAUSE;                public function AnimatorEffect(name:String,                                       type:uint,                                       precedence:int,                                       interval:uint)         {               _activated  = false;            _name       = name;            _type       = type;            _precedence = precedence;            _interval   = interval;        }                        public function initialize(animator:Animator,                                   anime:Anime,                                   precedence:Number = NaN):void         {               _animator   = animator;            _anime      = anime;                        // target is usually the _anime target, though might already be set to an alternative            if (! _target)             {                    _target = _anime.target;            }                        if (! isNaN(precedence))             {                      _precedence = precedence;       // precedence is overridden            }                        // assign startTime timestamp if one hasn't already been set            if (! _startTime)             {                this.startTime = getTimer();            }        }                        /**         * <p>whenDone()</p>         *          * <p>A convenience method that sets a function callback to         * be called when EffectEvent.EFFECT_DONE is dispatched from this effect.         * The function is triggered only once. Multiple consecutive whenDone()          * calls may be set.</p>         *          * @param funct Function callback called when effect finishes.         */        public function whenDone(funct:Function):void        {               if (funct != null)            {                // listen for effect done                var listener:Function = function (event:Event):void                 {                    removeEventListener(EffectEvent.EFFECT_DONE, listener);                    funct();                };                addEventListener(EffectEvent.EFFECT_DONE, listener);            }        }                        public function resolve(updateTime:uint,                                 forceInterval:Boolean = false):void         {            // calculate time passed since last update            _timePassed = updateTime - _updateTime;                        // record time of update            _updateTime = updateTime;                        var timeCap:uint = _animator.timeCap;            if (_interval > timeCap)             {                timeCap = _interval;            }                        // ensure time passed is never > than timeCap            if (_timePassed > timeCap)             {                _timePassed = timeCap;            }                        if (_updateTime < _startTime)             {                // this effect is not ready to trigger yet, exit                return;             }             else if (_timePassed >= _interval || forceInterval)             {                if (! _activated)                 {                    activate();                    _activated = true;                }                                // perform effect!                var resolved:Boolean = update();                // dispatchEvent(new EffectEvent(EffectEvent.EFFECT_UPDATED));                                if (resolved)                 {                    // check for cycling effects                    if (_cycles != DONT_CYCLE)                     {                        --_cycles;                        if (_cycles <= 0)                         {                            _type = TYPE_END;                        }                                                // can't cycle end, remove, or destroy types                        if (_type == TYPE_END ||                             _type == TYPE_REMOVE ||                            _type == TYPE_DESTROY)                         {                            _cycles = DONT_CYCLE;                        }                    }                                        // when effect finishes                    switch (_type)                     {                        case TYPE_PERSIST:                              break;                        case TYPE_END:      _anime.removeEffect(this);  break;                        case TYPE_REMOVE:   _anime.remove();            break;                        case TYPE_DESTROY:  _anime.destroy();           break;                        case TYPE_CYCLE:    cycle();                    break;                        case TYPE_REVERSE:  reverse();                  break;                        case TYPE_PAUSE:    pause();                    break;                    }                                        // if finished then dispatch event                    if (_cycles == DONT_CYCLE)                     {                        dispatchEffectDone();                    }                }            }        }                //        // called by Anime.as immediately after calling snapToEnd();        public function dispatchEffectDone():void         {            dispatchEvent(new EffectEvent(EffectEvent.EFFECT_DONE));        }                //        // primary functions for override        public function activate():void         {            throw new Error("Effect " + _name + " must override activate() method.");        }                public function update():Boolean         {            throw new Error("Effect " + _name + " must override update() method.");        }                public function cleanup():void {}                //        // secondary functions for override                public function snapToEnd():void         {            Logger.warning("Effect " + _name + " does not support snapToEnd() method.", Animator.WARNING_SNAP_TO_END_NOT_SUPPORTED);        }                public function cycle():void         {            Logger.warning("Effect " + _name + " does not support cycle() method.", Animator.WARNING_CYCLE_NOT_SUPPORTED);        }                public function reverse():void         {            Logger.warning("Effect " + _name + " does not support reverse() method.", Animator.WARNING_REVERSE_NOT_SUPPORTED);        }                public function pause():void         {            Logger.warning("Effect " + _name + " does not support pause() method.", Animator.WARNING_PAUSE_NOT_SUPPORTED);        }                public function unpause():void         {            Logger.warning("Effect " + _name + " does not support unpause() method.", Animator.WARNING_UNPAUSE_NOT_SUPPORTED);        }                        //        // print name of effect        public override function toString():String         {            return _name;        }                // accessors and mutators        public function get target():IEventDispatcher           { return _target; }        public function get name():String                       { return _name; }        public function get anime():Anime                       { return _anime; }        public function get type():uint                         { return _type; }        public function get precedence():int                    { return _precedence; }        public function get interval():uint                     { return _interval; }        public function get startTime():uint                    { return _startTime; }        public function get updateTime():uint                   { return _updateTime; }        public function get timePassed():int                    { return _timePassed; }        public function get cycles():int                        { return _cycles; }        public function get activated():Boolean                 { return _activated; }                public function set target(val:IEventDispatcher):void   { _target     = val; }        public function set name(val:String):void               { _name       = val; }        public function set type(val:uint):void                 { _type       = val; }        public function set interval(val:uint):void             { _interval   = val; }        public function set cycles(val:int):void                { _cycles     = val; }        public function set startTime(val:uint):void         {            // _updateTime must be initialized to _startTime            _startTime  = val;            _updateTime = _startTime;        }    }}