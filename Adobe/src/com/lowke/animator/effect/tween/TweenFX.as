////  TweenFX v 1.7 - animator package//  Russell Lowke, October 20th 2010////  Copyright (c) 2009-2010 Lowke Media//  see http://www.lowkemedia.com for more information//  see http://code.google.com/p/lowke-animator/ for code repository////  Permission is hereby granted, free of charge, to any person obtaining a //  copy of this software and associated documentation files (the "Software"), //  to deal in the Software without restriction, including without limitation //  the rights to use, copy, modify, merge, publish, distribute, sublicense, //  and/or sell copies of the Software, and to permit persons to whom the //  Software is furnished to do so, subject to the following conditions:// //  The above copyright notice and this permission notice shall be included in //  all copies or substantial portions of the Software.// //  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, //  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE //  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING //  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER  //  DEALINGS IN THE SOFTWARE. //////// start or end may be set to NaN, in which case most recent value is usedpackage com.lowke.animator.effect.tween{    import com.lowke.animator.Animator;    import com.lowke.animator.effect.AnimatorEffect;    import com.lowke.animator.effect.IAnimatorEffect;    import com.lowke.animator.effect.MultiEffectFX;    import com.lowke.animator.effect.tween.easing.NoEasing;        import flash.utils.getTimer;        public class TweenFX extends AnimatorEffect implements IAnimatorEffect     {        private var _variable:String;               // name of variable being changed        private var _start:Number;                  // start value of tween        private var _end:Number;                    // end value of tween        private var _range:Number;                  // range of the tween        private var _duration:uint;                 // duration of the tween        private var _endTime:uint;                  // time tween ends        private var _easingFunct:Function;          // easing function i.e. Sine.easeIn        private var _stackTween:Boolean = false;    // if true tween will stack with others        private var _value:Number;                  // value for variable being stacked                // accessing an external static references, such as Animator, has an overhead,        //  so, for performance sake, external vars are substituted with local references        public static const TYPE_END:int            = Animator.TYPE_END;        public static const PRECEDENCE_FIRST:int    = Animator.PRECEDENCE_FIRST;        public static const INTERVAL_NONE:uint      = Animator.INTERVAL_NONE;                //        // helper constructor methods for TweenFX        //                //        // TweenFX a list of vars in a duration        public static function varsTo(varsObjects:Vector.<Object>,                                      duration:uint,                                      easingFunct:Function = null,                                      name:String = "varsTo",                                      stackTween:Boolean = false,                                      type:int = TYPE_END):MultiEffectFX         {                                               // convert list of varsObjects into list of TweenFX effects            var tweens:Vector.<IAnimatorEffect> = new Vector.<IAnimatorEffect>;            for each (var object:Object in varsObjects)             {                var tween:TweenFX = new TweenFX(object["variable"],                    (object["start"] is Number) ? object["start"] : NaN,                    (object["end"] is Number) ? object["end"] : NaN,                    duration,                    easingFunct,                    stackTween,                    type);                tweens.push(tween);            }            return new MultiEffectFX(tweens, name, type);        }                public static function scaleTo(scale:Number,                                       duration:uint,                                       easingFunct:Function = null,                                       stackTween:Boolean = false,                                       type:int = TYPE_END):MultiEffectFX         {               var data:Vector.<Object> = new Vector.<Object>;            data.push({ variable:"scaleX", end:scale });            data.push({ variable:"scaleY", end:scale });            return varsTo(data, duration, easingFunct, "scaleTo", stackTween, type);        }                // it's sometimes useful to set the type to Animator.PERSIST to maintain the tweens        public static function xyTo(endX:Number,                                    endY:Number,                                    duration:uint,                                    easingFunct:Function = null,                                    stackTween:Boolean = false,                                    type:int = TYPE_END):MultiEffectFX        {               var data:Vector.<Object> = new Vector.<Object>;            data.push({ variable:"x", end:endX });            data.push({ variable:"y", end:endY });            return varsTo(data, duration, easingFunct, "xyTo", stackTween, type);        }                // useful when you want to have different easing functions for each axis        public static function easeXYTo(endX:Number,                                        endY:Number,                                        duration:uint,                                        xEasingFunct:Function = null,                                        yEasingFunct:Function = null,                                        stackTween:Boolean = false,                                        type:int = TYPE_END):MultiEffectFX        {            var tweens:Vector.<IAnimatorEffect> = new Vector.<IAnimatorEffect>;            tweens.push(new TweenFX("x", NaN, endX, duration, xEasingFunct, stackTween, type));            tweens.push(new TweenFX("y", NaN, endY, duration, yEasingFunct, stackTween, type));            return new MultiEffectFX(tweens, "easeXYTo", type);        }                public static function xyzTo(endX:Number,                                     endY:Number,                                     endZ:Number,                                     duration:uint,                                     easingFunct:Function = null,                                     stackTween:Boolean = false,                                     type:int = TYPE_END):MultiEffectFX        {               var data:Vector.<Object> = new Vector.<Object>;            data.push({ variable:"x", end:endX });            data.push({ variable:"y", end:endY });            data.push({ variable:"z", end:endZ });            return varsTo(data, duration, easingFunct, "xyzTo", stackTween, type);        }                //        // constructor                // set start to NaN to start at existing value of target        // set end to NaN to end at existing value of target        public function TweenFX(variable:String,                                start:Number,                                end:Number,                                duration:uint,                                easingFunct:Function = null,                                stackTween:Boolean = false,                                type:uint = TYPE_END)        {               super("TweenFX_" + variable, type, PRECEDENCE_FIRST, INTERVAL_NONE);                        _variable    = variable;            _start       = start;            _end         = end;            _duration    = duration;            _stackTween  = stackTween;                        // default easing function to NoEasing.easeNone            if (easingFunct == null)             {                _easingFunct = NoEasing.easeNone;            }             else             {                _easingFunct = easingFunct;            }        }                public override function activate():void         {               if (isNaN(_start))             {                _start = _target[_variable];            }             else             {                _target[_variable] = _start;            }            if (isNaN(_end))             {                _end = _target[_variable];            }            _value = _start;            _range = _end - _start;            _endTime = _startTime + _duration;        }                //        // used when changing values mid animation        // start or end may be set to NaN, in which case most recent value is used        public function recalibrate(start:Number,                                    end:Number,                                    duration:uint,                                    easingFunct:Function = null):void         {               _startTime = getTimer();            _start     = start;            _end       = end;            _duration  = duration;            _activated = false;            if (easingFunct != null)             {                _easingFunct = easingFunct;            }        }                public override function update():Boolean         {               var val:Number;            if (_updateTime >= _endTime)             {                if (_value == _end)                 {                    // Intentionally wait a cycle before sending true, allowing for multiple                        // effects timed together to finish cleanly before being removed.                    return true;                }                 else                 {                    val = _end;                }            } else             {                val = _easingFunct(_updateTime - _startTime, _start, _range, _duration);            }                        if (_stackTween)             {                valueTo(val);            }             else             {                _target[_variable] = val;                _value = val;            }                        return false;        }                public override function snapToEnd():void         {            _endTime = _updateTime;            if (_stackTween)             {                valueTo(_end);            }             else             {                _target[_variable] = _end;                _value = _end;            }        }                public override function cycle():void         {            // start the tween over            recalibrate(_start, _end, _duration);        }                public override function reverse():void         {            // reverse the tween            recalibrate(_end, _start, _duration);        }                        // print name of effect        public override function toString():String         {            return _name + " (" + _variable + ")";        }                //        // used for stacking tweens        public function valueTo(n:Number):void         {               // Change target variable only by the change in n            // This way tween effects can stack, even though they target the same variable            var nValue:Number = _target[_variable] + (n - _value);            _target[_variable] = nValue;                        // Flash introduces a rounding error with variables such as x, y, and alpha            // This error needs to be factored in            var err:Number = _target[_variable] - nValue;            _value = n + err;        }                //        // accessors and mutators        //                public function set variable(val:String):void       { _variable = val; }        public function set start(val:Number):void          { recalibrate(val, _end, _duration); }        public function set end(val:Number):void            { recalibrate(_start, val, _duration); }        public function set duration(val:uint):void         { recalibrate(_start, _end, val); }                public function get value():Number                  { return _value; }        public function get variable():String               { return _variable; }        public function get start():Number                  { return _start; }        public function get end():Number                    { return _end; }        public function get duration():uint                 { return _duration; }        public function get range():Number                  { return _range; }        public function get endTime():uint                  { return _endTime; }    }}