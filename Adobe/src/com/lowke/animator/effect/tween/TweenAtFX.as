////  TweenAtFX v 1.4 - animator package//  Russell Lowke, October 20th 2010////  Copyright (c) 2009-2010 Lowke Media//  see http://www.lowkemedia.com for more information//  see http://code.google.com/p/lowke-animator/ for code repository////  Permission is hereby granted, free of charge, to any person obtaining a //  copy of this software and associated documentation files (the "Software"), //  to deal in the Software without restriction, including without limitation //  the rights to use, copy, modify, merge, publish, distribute, sublicense, //  and/or sell copies of the Software, and to permit persons to whom the //  Software is furnished to do so, subject to the following conditions:// //  The above copyright notice and this permission notice shall be included in //  all copies or substantial portions of the Software.// //  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, //  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE //  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING //  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER  //  DEALINGS IN THE SOFTWARE. //////// start or end may be set to NaN, in which case most recent value is usedpackage com.lowke.animator.effect.tween{    import com.lowke.animator.Animator;    import com.lowke.animator.effect.AnimatorEffect;    import com.lowke.animator.effect.IAnimatorEffect;    import com.lowke.animator.effect.tween.easing.NoEasing;        import flash.utils.getTimer;        public class TweenAtFX extends AnimatorEffect implements IAnimatorEffect     {        private var _variable:String;               // name of variable being changed        private var _start:Number;                  // starting value of tween        private var _end:Number;                    // ending value of tween        private var _velocity:Number;               // velocity in units per millisecond        private var _duration:uint;                 // duration of the tween        private var _range:Number = NaN;            // range of the tween        private var _easingFunct:Function;          // easing function i.e. Sine.easeIn        private var _stackTween:Boolean = false;    // if true tween will stack with others        private var _value:Number;                  // value for variable being stacked                // accessing an external static references, such as Animator, has an overhead,        //  so, for performance sake, external vars are substituted with local references        public static const TYPE_END:uint           = Animator.TYPE_END;        public static const PRECEDENCE_FIRST:int    = Animator.PRECEDENCE_FIRST;        public static const INTERVAL_NONE:uint      = Animator.INTERVAL_NONE;                public function TweenAtFX(variable:String,                                  start:Number,                                  end:Number,                                  velocity:Number,                                  easingFunct:Function = null,                                  stackTween:Boolean = false,                                  type:uint = TYPE_END)         {             super("TweenAtFX_" + variable, type, PRECEDENCE_FIRST, INTERVAL_NONE);                        _variable   = variable;            _start      = start;            _end        = end;            _velocity   = velocity;            _stackTween = stackTween;                        // default easing function to NoEasing.easeNone            if (easingFunct == null)             {                _easingFunct = NoEasing.easeNone;            }             else             {                _easingFunct = easingFunct;            }        }                public override function activate():void         {            if (isNaN(_start))             {                _start = _target[_variable];            }             else             {                _target[_variable] = _start;            }            if (isNaN(_end))             {                _end = _target[_variable];            }            _value = _start;            _range = _end - _start;            _duration = Math.abs(_range/_velocity);        }                public override function cycle():void {            recalibrate(_start, _end);        }                public override function reverse():void {            recalibrate(_end, _start);        }                //        // used when changing values mid animation        // start or end may be set to NaN, in which case most recent value is used        // if velocity is set to NaN (default) then existing velocity is used        public function recalibrate(start:Number,                                    end:Number,                                    velocity:Number = NaN,                                    easingFunct:Function = null):void         {            _startTime = getTimer();            _start     = start;            _end       = end;            _activated = false;            if (! isNaN(velocity))             {                _velocity = velocity;            }            if (easingFunct != null)             {                _easingFunct = easingFunct;            }        }                public override function update():Boolean         {               var nVal:Number;            var rtn:Boolean = false;                        if (_updateTime >= (_startTime + _duration))             {                if (isNaN(_end))                 {                    _end = _target[_variable];                }                // set tween to destination value                nVal = _end;                rtn = true;                            }             else             {                // find current value                nVal = _easingFunct(_updateTime - _startTime, _start, _range, _duration);            }                        if (_stackTween)             {                valueTo(nVal);            }             else             {                _target[_variable] = nVal;            }                        return rtn;        }                public override function snapToEnd():void         {            _startTime = _updateTime;            if (_stackTween)             {                valueTo(_end);            }             else             {                _target[_variable] = _end;                _value = _end;            }        }                        // print name of effect        public override function toString():String         {            return _name + " (" + _variable + ")";        }                //        // used for stacking tweens        public function valueTo(n:Number):void         {               // Change target variable only by the change in n            // This way tween effects can stack, even though they target the same variable            var nValue:Number = _target[_variable] + (n - _value);            _target[_variable] = nValue;                        // Flash introduces a rounding error with variables such as x, y, and alpha            // This error needs to be factored in            var err:Number = _target[_variable] - nValue;            _value = n + err;        }                //        // accessors and mutators        //                public function set variable(val:String):void   { _variable = val; }        public function set start(val:Number):void      { recalibrate(val, _end); }        public function set end(val:Number):void        { recalibrate(NaN, val); }        public function set velocity(val:Number):void   { recalibrate(NaN, _end, val); }                public function get variable():String           { return _variable; }        public function get start():Number              { return _start; }        public function get end():Number                { return _end; }        public function get velocity():Number           { return _velocity; }        public function get duration():uint             { return _duration; }        public function get range():Number              { return _range; }    }}