////  FrictionFX v 1.2 - animator package//  Russell Lowke, August 7th 2008////  Copyright (c) 2008 Lowke Media//  see http://www.lowkemedia.com for more information//  see http://code.google.com/p/lowke-animator/ for code repository////  Permission is hereby granted, free of charge, to any person obtaining a //  copy of this software and associated documentation files (the "Software"), //  to deal in the Software without restriction, including without limitation //  the rights to use, copy, modify, merge, publish, distribute, sublicense, //  and/or sell copies of the Software, and to permit persons to whom the //  Software is furnished to do so, subject to the following conditions:// //  The above copyright notice and this permission notice shall be included in //  all copies or substantial portions of the Software.// //  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, //  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE //  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING //  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER  //  DEALINGS IN THE SOFTWARE. ////package com.lowke.animator.effect{    import com.lowke.animator.Animator;    import com.lowke.util.NumberUtil;    import flash.geom.Point;        public class FrictionFX extends AnimatorEffect implements IAnimatorEffect     {           private var _friction:Number;               // amount of friction        private var _velocityTarget:VelocityXYFX;     // target object of effect type Velocity                // accessing an external static references, such as Animator, has an overhead,        //  so, for performance sake, external vars are substituted with local references        public static const TYPE_PERSIST:uint       = Animator.TYPE_PERSIST;        public static const PRECEDENCE_FIRST:int    = Animator.PRECEDENCE_FIRST;        public static const INTERVAL_NONE:uint      = Animator.INTERVAL_NONE;                        public function FrictionFX(friction:Number)         {               super("FrictionFX",  TYPE_PERSIST, PRECEDENCE_FIRST, INTERVAL_NONE);                        _friction  = friction;        }                        public override function activate():void         {               if (_target is VelocityXYFX)             {                _velocityTarget = _target as VelocityXYFX;            }             else             {                _velocityTarget = _anime.getEffect("Velocity") as VelocityXYFX;                if (! _velocityTarget)                 {                    throw new Error("FrictionFX effect needs a Velocity effect as a target");                }            }        }                        public override function update():Boolean         {               if (_velocityTarget)             {                // limit friction to length of velocity                var friction:Number = _friction*_timePassed;                var length:Number = _velocityTarget.vel.length;                if (friction > length)                 {                     friction = length;                 }                                // determine x and y component of friction                var angle:Number = NumberUtil.vectorToAngle(_velocityTarget.vel);                var f:Point = NumberUtil.angleToVector(angle, friction);                                _velocityTarget.velX += f.x;                _velocityTarget.velY += f.y;            }                        return false;        }                public function get friction():Number         {             return _friction;         }    }}