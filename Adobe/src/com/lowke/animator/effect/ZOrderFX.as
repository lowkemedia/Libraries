////  ZOrderFX v 1.1 - animator package//  Russell Lowke, September 24th 2008// //  Copyright (c) 2008 Lowke Media//  see http://www.lowkemedia.com for more information//  see http://code.google.com/p/lowke-animator/ for code repository////  Permission is hereby granted, free of charge, to any person obtaining a //  copy of this software and associated documentation files (the "Software"), //  to deal in the Software without restriction, including without limitation //  the rights to use, copy, modify, merge, publish, distribute, sublicense, //  and/or sell copies of the Software, and to permit persons to whom the //  Software is furnished to do so, subject to the following conditions:// //  The above copyright notice and this permission notice shall be included in //  all copies or substantial portions of the Software.// //  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, //  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE //  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING //  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER  //  DEALINGS IN THE SOFTWARE. ////// ZOrderFX effect is often used in conjunction with AutoScale effect// usage:////      import com.lowke.animator.Animator;//      import com.lowke.animator.effects.ZOrderFX;////      // to start Z ordering//      Animator.anime(displayObject).addEffect(new ZOrderFX());////      yZOrderOffsetpackage com.lowke.animator.effect{    import com.lowke.animator.Animator;        import flash.display.DisplayObject;    import flash.display.Sprite;        public class ZOrderFX extends AnimatorEffect implements IAnimatorEffect     {        private var _sprite:Sprite;             // _target cast as a sprite        private var _backItems:Array;           // array of objects sent to the back of the z order        private var _frontItems:Array;          // array of objects floating on top of the z order        private var _oldZArray:Array;           // previous array of DisplayObjects        private var _descending:Boolean;        // if true then sort y in DESCENDING order                // accessing an external static references, such as Animator, has an overhead,        //  so, for performance sake, external vars are substituted with local references        public static const TYPE_PERSIST:uint       = Animator.TYPE_PERSIST;        public static const PRECEDENCE_LATER:int    = Animator.PRECEDENCE_LATER;        public static const INTERVAL_NONE:uint      = Animator.INTERVAL_NONE;                public function ZOrderFX(descending:Boolean = false)         {               super("ZOrderFX",                TYPE_PERSIST,                 PRECEDENCE_LATER + 1,       // later and a bit                INTERVAL_NONE);                        _backItems  = new Array();            _frontItems = new Array();            _oldZArray  = new Array();            _descending = descending;        }                public override function activate():void         {            _sprite = _target as Sprite;        }                public override function update():Boolean         {               // array of display objects to be z-ordered            var zArray:Array = new Array();                        var nItems:uint = _sprite.numChildren;                      var y:Number;            var dObj:DisplayObject;            var index:int;            for(var i:uint = 0; i < nItems; ++i)             {                // get the object                dObj = _sprite.getChildAt(i);                                // if item on _backItems list then send to back                index = _backItems.indexOf(dObj);                if (index > -1)                 {                    y = int.MIN_VALUE + index;                }                 else                 {                      // if item on _frontItems list then send to front                    index = _frontItems.indexOf(dObj);                    if (index > -1)                     {                        y = int.MAX_VALUE - index;                    }                     else                     {                         // otherwise zOrder                        try                         {                            y = (dObj as Object)["mZ"];                        }                         catch (err:Error)                         {                            y = dObj.y;                        }                    }                }                zArray.push( { dObj:dObj, y:y } );            }                        // sort the array using y parameter            if (_descending)             {                zArray.sortOn("y", Array.NUMERIC | Array.DESCENDING);            }             else             {                zArray.sortOn("y", Array.NUMERIC);            }                        if (! sameZOrder(zArray, _oldZArray))             {                // z order has changed,                //  so switch display objects arround                for (var j:uint = 0; j < nItems; ++j)                 {                    if (_sprite.contains(zArray[j]["dObj"]))                     {                        _sprite.setChildIndex(zArray[j]["dObj"], j);                    }                }            }                        // remember the last zArray            _oldZArray = zArray;                        return false;        }                //        // return true if arrayA has the same zOrder as arrayB        private function sameZOrder(arrayA:Array, arrayB:Array):Boolean         {            var length:uint = arrayA.length;            if (length == arrayB.length)             {                for(var i:uint = 0; i < length; ++i)                 {                    if (arrayA[i]["dObj"] != arrayB[i]["dObj"])                     {                        return false;                    }                }                return true;            }             else             {                return false;            }        }                // send to back most of back items        public function sendToBack(dObj:DisplayObject):void         {               // push dObj to end of _backItems array            sendToZOrder(dObj);            _backItems.unshift(dObj);           }                // send to front most of front items        public function sendToFront(dObj:DisplayObject):void         {               // unshift dObj to front of _frontItems array            sendToZOrder(dObj);            _frontItems.unshift(dObj);        }                // ensure dObj is removed from both _frontItems and _backItems list        // so it ZOrders normally again        public function sendToZOrder(dObj:Object):void         {            removeFrom(_frontItems, dObj);            removeFrom(_backItems, dObj);        }                //        // general tool to remove object from an Array        private function removeFrom(array:Array, dObj:Object):Boolean         {               var index:int = array.indexOf(dObj);            if (index > -1)             {                array.splice(index, 1);                return true;            }            return false;        }    }}