////  ButtonController v 1.7 - buttonController package//  Russell Lowke, June 30th 2013////  Copyright (c) 2008-2013 Lowke Media//  see http://www.lowkemedia.com for more information//  see http://code.google.com/p/lowke-buttoncontroller/ for code repository//  see http://code.google.com/p/lowke/ for entire lowke code repository////  Permission is hereby granted, free of charge, to any person obtaining a //  copy of this software and associated documentation files (the "Software"), //  to deal in the Software without restriction, including without limitation //  the rights to use, copy, modify, merge, publish, distribute, sublicense, //  and/or sell copies of the Software, and to permit persons to whom the //  Software is furnished to do so, subject to the following conditions:// //  The above copyright notice and this permission notice shall be included in //  all copies or substantial portions of the Software.// //  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, //  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE //  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING //  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER  //  DEALINGS IN THE SOFTWARE. ////package com.lowke.buttonController{    import com.lowke.Delayer;    import com.lowke.buttonController.controller.FrameController;    import com.lowke.buttonController.controller.KeyController;    import com.lowke.buttonController.event.UnpressEvent;    import com.lowke.logger.Logger;    import com.lowke.playFrames.PlayFrames;    import com.lowke.playFrames.event.FramesFinishedEvent;        import flash.display.MovieClip;    import flash.display.Sprite;    import flash.display.Stage;    import flash.events.Event;    import flash.events.IEventDispatcher;    import flash.events.MouseEvent;    import flash.media.Sound;    import flash.media.SoundTransform;    import flash.text.TextField;    import flash.utils.Dictionary;            /**     * @author Russell Lowke     */    public class ButtonController implements IEventDispatcher, IStandardButton    {                //        // error, warning and ifo IDs                public static const LOG_PREFIX:String                                           = "BTN";        public static const WARNING_GIVEN_EMPTY_VIEW:String                             = "BTN00";        public static const WARNING_NO_TEXT_FIELD_CANT_SET_TEXT:String                  = "BTN01";        public static const WARNING_DONT_USE_UNDERSCORE:String                          = "BTN02";        public static const WARNING_DASH_INDICATOR_IGNORED:String                       = "BTN03";        public static const WARNING_BUTTON_VIEW_CANT_BE_ROOT:String                     = "BTN04";        public static const WARNING_CANT_FIND_UP_LABEL:String                           = "BTN05";        public static const WARNING_FRAME_CONTROLLER_NEEDS_MOVIECLIP:String             = "BTN06";        public static const DEBUG_REMOVED_FROM_STAGE:String                             = "BTN07";                /** frame constants */        public static const UP:String               = FrameController.UP;        public static const OVER:String             = FrameController.OVER;        public static const DOWN:String             = FrameController.DOWN;        public static const SELECTED:String         = FrameController.SELECTED;        public static const DISABLED:String         = FrameController.DISABLED;                public static const HOT_SPOT:String         = FrameController.HOT_SPOT;                // sound constants        public static const SND_CLICK:String        = "soundClick";        public static const SND_OVER:String         = "soundOver";        public static const SND_OUT:String          = "soundOut";                // text constants        public static const TEXT_WRAPPER:String = "textWrapper";        public static const TEXT_FIELD:String = "textField";                        // dictionary of listeners attached by onClick() helper function        private static var _listenerDictionary:Dictionary = new Dictionary(true);        private static var _defaultClickSound:Sound;        // default click sound;                // member variables        private var _view:Sprite;                           // typically a MovieClip used by the button, but it can also be a Sprite        private var _frameController:FrameController;       // controls frames on _view        private var _state:String = "";                     // state defaults as "", another state might be "highlighted"        private var _buttonMode:Boolean;                    // indicates if behaving like a button        private var _enabled:Boolean = true;                // if false then button disabled and shown as greyed out        private var _selected:Boolean = false;              // if true then button shown as selected        private var _rolled:Boolean = false;                // (read only) true if the mouse over the button and "up" frame shown        private var _down:Boolean = false;                  // (read only) true if the button is down and "down" frame shown        private var _disabledAlpha:Number = 0.35;           // alpha value used on the button when disabled if no _disabledFrame        private var _clickSound:Sound;                      // sound triggered when button clicked        private var _rolloverSound:Sound;                   // sound triggered on rollOver        private var _rolloutSound:Sound;                    // sound triggered on rollOut        private var _mute:Boolean = false;                  // if true, button sounds are supressed        private var _snapFromUp:Boolean = false;            // indicates to "snap" (not animate) when leaving UP frame        private var _snapOverToDown:Boolean = false;        // indicates to "snap" (not animate) from the OVER frame to DOWN frame        private var _snapOverToUp:Boolean = false;          // indicates to "snap" (not animate) from the OVER frame to UP frame        private var _snapFromDown:Boolean = false;          // indicates to "snap" (not animate) when leaving DOWN frame        private var _persist:Boolean = false;               // if persist true then button controller not auto removed when removed from stage        private var _misc:*;                                // useful miscellaneous holder that can be set and retrieved                        /**         * ButtonController constructor         *          * @param view The MovieClip to be controlled as a button.         */        public function ButtonController(view:Sprite)        {               super();            this.view = view;            _clickSound = _defaultClickSound;        }                public function close():void         {            if (! view)             {                return;            }                        removeOnClick();            removeListeners(_view);                        // remove base listeners as well            _view.removeEventListener(MouseEvent.CLICK, blockClickEvent);            _view.removeEventListener(Event.ADDED_TO_STAGE, addedToStage);            _view.removeEventListener(Event.REMOVED_FROM_STAGE, removedFromStage);                        _view = null;        }                        /**         * Adds mouse listeners to a Sprite so that the Sprite also responds         * as the button.         * Note: this is used internally to add listeners to _view         *          * @param sprite The Sprite view to have mouse listeners added to it.         */        public function addListeners(sprite:Sprite):void        {            if (sprite == _view && ! _buttonMode || ! sprite)             {                // not in button mode, and should not respond as a button                return;            }                        // indicate that the _view is a button, this adds it            //  to the automatic tab order and gives it a handCursor.            sprite.buttonMode = true;                        // disable all children from mouse response. Buttons do not enable            //  mouse interactivity for child objects as it confuses event flow.            sprite.mouseChildren = false;                        if (sprite != _view)             {                sprite.addEventListener(MouseEvent.CLICK, blockClickEvent, false, int.MAX_VALUE);            }                        sprite.addEventListener(MouseEvent.CLICK, clickEvent, false, int.MAX_VALUE - 1);            sprite.addEventListener(MouseEvent.MOUSE_DOWN, mouseDownEvent);            sprite.addEventListener(MouseEvent.ROLL_OVER, rollOverEvent);            sprite.addEventListener(MouseEvent.ROLL_OUT, rollOutEvent);        }                /**         * Removes button mouse listeners from a Sprite, stopping it from          * responding as the button.         * Note: this is used internally to remove listeners on _view         * This is not an alternitive to close(), use close() if you want          * to close the controller and remove button functionality.         *          * @param sprite The Sprite to have mouse listeners removed from it.         */        public function removeListeners(sprite:Sprite):void        {            sprite.buttonMode = false;            sprite.mouseChildren = true;                        if (sprite != _view)             {                sprite.removeEventListener(MouseEvent.CLICK, blockClickEvent);            }                        sprite.removeEventListener(MouseEvent.CLICK, clickEvent);            sprite.removeEventListener(MouseEvent.MOUSE_DOWN, mouseDownEvent);            sprite.removeEventListener(MouseEvent.ROLL_OVER, rollOverEvent);            sprite.removeEventListener(MouseEvent.ROLL_OUT, rollOutEvent);        }                /**         * Updates the button view to a frame according to _selected, _rolled,          * _down and _enabled         *          * @param snapTo If true the button will snap to rather than animate.         */        public function update(snapTo:Boolean = false,                                funct:Function = null):void        {               if (! _frameController)             {                // if the view is a Sprite it has no frames (or frameController)                return;            }                        if (! _enabled)             {                _frameController.gotoFrame(DISABLED);                                // set disabled alpha if no disabled frame                if (_frameController.noDisabledFrame())                 {                    _view.alpha = _disabledAlpha;                }            }             else             {                var startFrame:String = frame;                var endFrame:String;                if (_selected)                 {                    endFrame = SELECTED;                }                 else if (_down)                 {                    endFrame = DOWN;                }                 else if (_rolled)                 {                    endFrame = OVER;                }                 else                 {                    endFrame = UP;                }                                if (frame == DISABLED || frame == SELECTED ||      // always snap to frame if returning from DISABLED or SELECTED                    (_snapFromUp && startFrame == UP) ||                    (_snapOverToDown && startFrame == OVER && endFrame == DOWN) ||                    (_snapOverToUp && startFrame == OVER && endFrame == UP) ||                    (_snapFromDown && startFrame == DOWN))                 {                    snapTo = true;                }                                if (snapTo)                 {                    startFrame = endFrame;                }                                // play the frames                _frameController.playFrames(startFrame, endFrame, PlayFrames.TYPE_END, funct);            }        }                /**         * Resets the button         */        public function reset():void        {            if (_buttonMode && mouseOverSprite(_view))            {                _rolled = true;            }            else             {                _rolled = false;            }            _down = false;                        update(true);        }                private function rollOverEvent(event:MouseEvent):void        {            playSound(SND_OVER);            _rolled = true;            update();        }                private function rollOutEvent(event:MouseEvent):void        {            playSound(SND_OUT);            _rolled = false;            _down = false;            update();        }                private function mouseDownEvent(event:MouseEvent):void        {            _down = true;            update();        }                private function clickEvent(event:MouseEvent):void        {               playSound(SND_CLICK);                        if (_frameController && _frameController.playing)             {                // will resend the event once button has finished animating                event.stopImmediatePropagation();                                // A clickEvent should be preceeded by a mouseDownEvent,                //  so button should already be displayed or animating as pressed down,                // unless the mouse was taken off the button while held down                if (! _down)                 {                    // first process a mouseDown as mouse was taken off the button while held down                    _view.dispatchEvent(new MouseEvent(flash.events.MouseEvent.MOUSE_DOWN, true, false, _view.mouseX, _view.mouseY));                }                                // remove listeners to prevent                //  other clicks interrupting click sequence                removeListeners(_view);                                // wait for button to finish animating to down position before unpress                var listener:Function = function (listenerEvent:Event):void                 {                    _view.removeEventListener(FramesFinishedEvent.PLAY_FRAMES_FINISHED, listener);                    unpress(event);                };                _view.addEventListener(FramesFinishedEvent.PLAY_FRAMES_FINISHED, listener);            }             else             {                unpress();            }        }                private function unpress(event:MouseEvent = null):void        {               if (event)             {                _view.dispatchEvent(event);            }                        _down = false;            update(false, dispatchUnpress);        }                private function dispatchUnpress():void        {               if (! _view)             {                // view has been removed, so exit.                return;            }                        // start listening to mouse clicks again            addListeners(_view);                        _view.dispatchEvent(new UnpressEvent(UnpressEvent.UNPRESS, true));                        // check for dicovered mouse rollout while button was animating            if (! mouseOverSprite(_view))             {                _view.dispatchEvent(new MouseEvent(MouseEvent.ROLL_OUT, true, false, _view.mouseX, _view.mouseY));            }        }                // called by a high priority listener to block        //  click events when the button is disabled        private function blockClickEvent(event:MouseEvent):void        {            if (! _enabled)             {                event.stopImmediatePropagation();            }        }                private function addedToStage(event:Event):void        {               addListeners(_view);                        // buttons with buttonMode switched off don't need to             //  be reset when added to stage. Conversely, buttons when added to            //  stage should be reset so their old state doesn't persist.            if (_buttonMode)             {                reset();            }        }                private function removedFromStage(event:Event):void        {               if (_persist)             {                removeListeners(_view);            }             else             {                Logger.debug("ButtonController for view \"" +  _view.name + "\" auto-removed because it was removed from the stage.\n" +                    "Set persist to true to prevent this from happening.\n" +                    "ButtonControllers set to persist should be disposed of using close() when no longer needed.", DEBUG_REMOVED_FROM_STAGE);                close();            }        }                /**         * Simulates the button being rolled by sending it a MOUSE_OVER         */        public function rolloverButton():void        {               if (_view.visible)             {                // have the button dispatch a mouse down event for emulation                _view.dispatchEvent(new MouseEvent(flash.events.MouseEvent.ROLL_OVER));            }        }                /**         * Simulates the button being rolled by sending it a MOUSE_OVER         */        public function rolloutButton():void        {               if (_view.visible)             {                  // have the button dispatch a mouse down event for emulation                _view.dispatchEvent(new MouseEvent(flash.events.MouseEvent.ROLL_OUT));            }        }                /**         * Simulates the button being clicked, including dispatching MOUSE_DOWN,          * CLICK and MOUSE_UP events         *          * @param pressDuration Duration which the button is displayed as down.         */        public function clickButton(pressDuration:uint = 0):void        {               if (! _down && _view.visible)             {                if (! _rolled)                 {                    rolloverButton();                }                                // have the button dispatch a mouse down event for emulation                _view.dispatchEvent(new MouseEvent(flash.events.MouseEvent.MOUSE_DOWN));                                if (! pressDuration)                 {                    // wait a frame to ensure button shown drawn as down					Delayer.nextFrame(finishClickButton);                }                 else                 {                    Delayer.delay(pressDuration, finishClickButton);                }            }        }                private function finishClickButton():void        {            if (_down && _view.visible)             {                _view.dispatchEvent(new MouseEvent(flash.events.MouseEvent.CLICK));                _view.dispatchEvent(new MouseEvent(flash.events.MouseEvent.MOUSE_UP));            }        }                public function playSound(snd:String):void        {               if (_mute)             {                return;            }                        switch (snd)             {                case SND_CLICK:                    if (_clickSound)                     {                        _clickSound.play();                    }                    break;                  case SND_OVER:                    if (_rolloverSound)                     {                        _rolloverSound.play();                    }                    break;                case SND_OUT:                    if (_rolloutSound)                     {                        _rolloutSound.play();                    }                    break;            }        }                        //        // accessors and mutators        //                public function set view(view:Sprite):void        {            // warn if given an empty view            if (! view)             {                Logger.warning("ButtonController was given an empty view.", WARNING_GIVEN_EMPTY_VIEW);                view = new Sprite();            }                                    if (view is MovieClip)             {                var movieClip:MovieClip = view as MovieClip;                movieClip.stop();                _frameController = new FrameController(this);                                // warn if view is root of a scene                if (stringHasValue(movieClip.currentScene.name))                 {                    Logger.warning("A button's view can't be the root timeline of a scene.\n" +                        "Issue on button view name:\"" + (view as MovieClip).name + "\" " + view + " which is root of scene:\"" + (view as MovieClip).currentScene.name + "\"", WARNING_BUTTON_VIEW_CANT_BE_ROOT);                }            }             else             {                _frameController = null;            }                        // prepare to transfer any onClick listener to the new view            var oldListener:Function = _listenerDictionary[this];                        close();            _view = view;                        if (oldListener != null)             {                // add oldListener to new _view                _view.addEventListener(MouseEvent.CLICK, oldListener, false, 0, true);                _listenerDictionary[this] = oldListener;            }                        _view.addEventListener(MouseEvent.CLICK, blockClickEvent, false, int.MAX_VALUE);            _view.addEventListener(Event.ADDED_TO_STAGE, addedToStage);            _view.addEventListener(Event.REMOVED_FROM_STAGE, removedFromStage);            if (_frameController)             {                _frameController.initialize();            }                        // reset the state            state = "";                        // Note: buttonMode is overridden and will call addListeners(_view)            buttonMode = true;                        reset();        }                /**          * If set to false then the button ceases to behave as a button         * and the _view can be manipulated as a regular MovieClip         */        public function set buttonMode(value:Boolean):void         {            _buttonMode = value;                        if (_buttonMode)             {                // Note: _view.buttonMode = true is set in addListeners().                addListeners(_view);            }             else             {                // Note: _view.buttonMode = false is set in removeListeners().                removeListeners(_view);            }                        reset();        }                public function set visible(value:Boolean):void         {            if (_view)            {                _view.visible = value;                update(true);            }        }                /**          * Buttons with their enabled set to false display as diabled          * and will not respond to the mouse         */        public function set enabled(value:Boolean):void         {            if (_enabled != value)             {                _enabled = value;                                // the main reason we need to set _view.enabled                // parameter is that it toggles automatic tab order                // on or off as we are using (_view as MovieClip).buttonMode                                if (_enabled)                 {                    // returning the alpha to 1 is done here rather                    // than in update() so to be less destructive,                    // the user might be using a custom alpha                    if (_frameController && _frameController.noDisabledFrame())                     {                        _view.alpha = 1;                    }                                        // automatic tab order on                    if (_view is MovieClip)                     {                        (_view as MovieClip).enabled = true;                    }                                        addListeners(_view);                    update();                }                 else                 {                                        // automatic tab order off                    if (_view is MovieClip)                     {                        (_view as MovieClip).enabled = false;                    }                                        removeListeners(_view);                    reset();                }            }        }                        /**          * Changes the state of the button,         * which declares the _upFrame, _overFrame, _downFrame and _disableFrame          * values used.         *          * @param value The name of the state to change to.         * @throws Throws an error if conflicting frame on _view MovieClip.         */        public function set state(value:String):void         {            if (value != _state)             {                _state = value;                if (_frameController)                 {                    _frameController.setFrames(_state);                }                update(true);            }        }                /**          * If true shows the button as selected and showing the "down" frame.         * Sometimes it is desirable to also set the buttonMode to false         * to prevent the user from further selecting the button.         */        public function set selected(value:Boolean):void         {            if (value != _selected)             {                _selected = value;                update();            }        }                /**          * Declares the alpha value of the button when shown as disabled.         * If a "disabled" frame has been decalred this property is not used         */        public function set disabledAlpha(value:Number):void         {            if (value != _disabledAlpha)             {                _disabledAlpha = value;                update();            }        }                        //        // key control is delegated out to KeyController object        //                /**          * @param key Button responds to key.         */        public function addKey(key:String):void         {             KeyController.addKey(_view, key);         }                /**          * @param keyCode Button responds to key code.         */        public function addKeyCode(keyCode:int):void         {             KeyController.addKeyCode(_view, keyCode);         }                /**          * @param key Button ceases to respond key.         * @param giveWarning If true warning given if button wasn't previously          *                    responing to key.         */        public function removeKey(key:String):void         {             KeyController.removeKey(_view, key);         }                /**          * @param keyCode Button ceases to respond key code.         * @param giveWarning If true warning given if button wasn't previously          *                    responing to key code.         */        public function removeKeyCode(keyCode:int):void         {             KeyController.removeKeyCode(_view, keyCode);         }                /**          * Clears any key codes assigned to this button to respond to.         */        public function clearKeys():void         {             KeyController.clearKeys(_view);         }                /**         * With buttons it's generally better to use a weak listener.         * This method makes the listener weak by default.         */        public function addWeakListener(type:String,                                         listener:Function,                                         useCapture:Boolean = false,                                         priority:int = 0,                                         useWeakReference:Boolean = true):void         {            _view.addEventListener(type, listener, useCapture, priority, useWeakReference);        }                        /**         * Passthrough method. It's the view that must have eventlisteners added          * to it as it's the view that's in the display list.         */        public function addEventListener(type:String,                                          listener:Function,                                          useCapture:Boolean = false,                                          priority:int = 0,                                          useWeakReference:Boolean = false):void         {            _view.addEventListener(type, listener, useCapture, priority, useWeakReference);        }                /**         * Passthrough method. As the listeners were added to the view, so too          * must they be removed from the view.         */        public function removeEventListener(type:String,                                             listener:Function,                                             useCapture:Boolean=false):void        {            _view.removeEventListener(type, listener, useCapture);        }                /**         * Passthrough method, events dispatched are actually dispatched           * from the _view         */        public function dispatchEvent(event:Event):Boolean        {            return _view.dispatchEvent(event);        }                /**         * Passthrough method, check for listener on the _view         */        public function hasEventListener(type:String):Boolean        {            return _view.hasEventListener(type);        }                /**         * Passthrough method, check for willTrigger on the _view         */        public function willTrigger(type:String):Boolean        {            return _view.willTrigger(type);        }                public function set tabIndex(index:int):void        {            _view.tabEnabled = true;            _view.tabIndex = index;        }                        //        // Accessors and Mutators        //                /** Default click sound used by buttons. */        public static function set defaultClickSound(value:Sound):void        {            _defaultClickSound = value;			preloadSound(_defaultClickSound);        }                /** Sets the click sound used by this button. */        public function set clickSound(value:Sound):void        {             _clickSound = value;			preloadSound(_clickSound);        }                /** Sets the rollover sound used by this button. */        public function set rolloverSound(value:Sound):void        {            _rolloverSound = value;			preloadSound(_rolloverSound);        }                /** Sets the rollout sound used by this button. */        public function set rolloutSound(value:Sound):void        {            _rolloutSound = value;			preloadSound(_rolloutSound);        }                /** Sets the frames per second (fps) that the button is to animate at*/        public function set fps(value:uint):void        {             _frameController.fps = value;         }                /** Useful miscellaneous holder object assciated with the button. */        public function set misc(value:*):void        {             _misc = value;         }                /**          * If true sounds assigned to this button are not played.          * This can be convenient in cases when the button becomes selected         * and you temporarily don't want the rollover and click sounds to play.          */        public function set mute(value:Boolean):void        {             _mute = value;         }                /** Indicates to "snap" (not animate) when leaving the UP frame. */        public function set snapFromUp(value:Boolean):void        {             _snapFromUp = value;         }                /** Indicates to "snap" (not animate) from the OVER frame to the DOWN frame. */        public function set snapOverToDown(value:Boolean):void        {             _snapOverToDown = value;         }                /** Indicates to "snap" (not animate) from the OVER frame to the UP frame. */        public function set snapOverToUp(value:Boolean):void        {             _snapOverToUp = value;         }                /** Indicates to "snap" (not animate) when leaving the DOWN frame. */        public function set snapFromDown(value:Boolean):void        {             _snapFromDown = value;         }                /** Convenience for access to text on TextField in button. */        public function set text(value:String):void         {             if (! textField)             {                // give warning no text field found                Logger.warning("No text field found on button " + _view.name + ". Button text can't be set to \"" + value + "\"\n" +                    "Text should be in the button in a MovieClip instance named \"" + TEXT_WRAPPER + "\" which contains a TextField instance named \"" + TEXT_FIELD + "\".",                    WARNING_NO_TEXT_FIELD_CANT_SET_TEXT);            }             else             {                textField.text = value;            }        }                /** Indicates the button should persist rather than be auto-removed when removed from stage.          * ButtonControllers set to persist should be disposed of using close() when no longer needed. */        public function set persist(value:Boolean):void        {             _persist = value;         }                        public function get enabled():Boolean           { return _enabled; }        public function get buttonMode():Boolean        { return _buttonMode; }        public function get view():*                    { return _view; }        public function get frame():String              { return _frameController.frame; }        public function get state():String              { return _state; }        public function get selected():Boolean          { return _selected; }        public function get disabledAlpha():Number      { return _disabledAlpha; }        public function get rolled():Boolean            { return _rolled; }        public function get down():Boolean              { return _down; }        public function get fps():uint                  { return _frameController.fps; }        public function get clickSound():Sound          { return _clickSound; }        public function get rolloverSound():Sound       { return _rolloverSound; }        public function get rolloutSound():Sound        { return _rolloutSound; }        public function get mute():Boolean              { return _mute; }        public function get snapFromUp():Boolean        { return _snapFromUp; }        public function get snapOverToDown():Boolean    { return _snapOverToDown; }        public function get snapOverToUp():Boolean      { return _snapOverToUp; }        public function get snapFromDown():Boolean      { return _snapFromDown; }        public function get persist():Boolean           { return _persist; }        public function get misc():*                    { return _misc; }        public function get text():String        {            var field:TextField = textField;            if (field) 			{                return field.text;            }                        return null;        }                /** Convenience method for getting textField on the button. */        public function get textField():TextField        {            var textField:TextField;                        // if there's no view then there's no textField            if (! _view)             {                return null;            }                        // 1st check for text field on specific textWrapper            var textWrapper:MovieClip = _view[TEXT_WRAPPER];            if (textWrapper)             {                textField = searchForTextField(textWrapper);                if (textField)                 {                    return textField;                }            }                        // 2nd check for text field on the view            textField = searchForTextField(_view);            if (textField)             {                return textField;            }                        return null;        }                private function searchForTextField(sprite:Sprite):TextField        {            var textField:TextField = sprite[TEXT_FIELD];            if (textField)             {                return textField;            }             else             {                // return 1st TextField on the sprite                for (var i:uint = 0; i < sprite.numChildren; ++i)                 {                    if (sprite.getChildAt(i) is TextField)                     {                        return sprite.getChildAt(i) as TextField;                    }                }            }                        return null;        }                // passthrough methods to view        public function get x():Number                  { return _view.x; }        public function get y():Number                  { return _view.y; }        public function get width():Number              { return _view.width; }        public function get height():Number             { return _view.height; }        public function get stage():Stage               { return _view.stage; }        public function set x(value:Number):void        { _view.x = value; }        public function set y(value:Number):void        { _view.y = value; }                        /**         * <p>onClick()</p>         *          * Convenience method that sets a function callback to be called          * and specific arguments passed to it whenever the button is clicked.         *          * @param funct Function callback called whenever button clicked.         */        public function onClick(callbackFunct:Function):void        {   			// remove any existing onClick            removeOnClick();                        // add weak listener            var listener:Function = function (event:MouseEvent):void             {                if (_buttonMode)                {                    callbackFunct();                }            };            _view.addEventListener(MouseEvent.CLICK, listener, false, 0, true);            _listenerDictionary[this] = listener;        }                public function removeOnClick():void        {            // remove any existing onClick listener            var oldListener:Function = _listenerDictionary[this];            if (_view && oldListener != null)             {                _view.removeEventListener(MouseEvent.CLICK, oldListener);                _listenerDictionary[this] = null;                delete _listenerDictionary[this];            }        }                        //        // Static helper functions        //        		/**		 * Preloads a sound by playing it a zero volume. 		 * This ensures the sound is played quickly when played.		 * 		 * @param sound Sound being preloaded.		 */		public static function preloadSound(sound:Sound):void		{			sound.play(0, 0, new SoundTransform(0));		}				        /**         * Return true if the mouse over sprite         *          * @param sprite Sprite being tested for         * @param shapeFlag If true shape of sprite checked (slower)         *               insted of just the bounding rectangle         */        public static function mouseOverSprite(sprite:Sprite, 											   shapeFlag:Boolean = true):Boolean         {            return (sprite && sprite.stage &&                    sprite.hitTestPoint(sprite.stage.mouseX, sprite.stage.mouseY, shapeFlag));        }                        /**         * Specifies whether the specified string is either non-null, or contains         * characters (i.e. length is greater that 0)         *          * @param string The string which is being checked for a value         * @return Returns true if the string has a value         */        private static function stringHasValue(string:String):Boolean        {            return (string != null && string.length > 0);                   }    }}