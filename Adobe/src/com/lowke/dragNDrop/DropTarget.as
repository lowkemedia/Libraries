////  DropTarget v 1.0 - dragNDrop package//  Russell Lowke, April 14th 2010////  Copyright (c) 2010 Lowke Media//  see http://www.lowkemedia.com for more information//  see http://code.google.com/p/lowke/ for code repository////  Permission is hereby granted, free of charge, to any person obtaining a //  copy of this software and associated documentation files (the "Software"), //  to deal in the Software without restriction, including without limitation //  the rights to use, copy, modify, merge, publish, distribute, sublicense, //  and/or sell copies of the Software, and to permit persons to whom the //  Software is furnished to do so, subject to the following conditions:// //  The above copyright notice and this permission notice shall be included in //  all copies or substantial portions of the Software.// //  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, //  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE //  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING //  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER  //  DEALINGS IN THE SOFTWARE. ////package com.lowke.dragNDrop{           import flash.display.MovieClip;    import flash.geom.Point;            public class DropTarget extends MovieClip     {           // states        public static var NORMAL:String = "normal_up_state";        public static var HIGHLIGHT:String = "highlight_state";                private var _view:MovieClip;                            // MovieClip view for the button        private var _state:String;                              // current state, NORMAL, DRAG, RIGHT or WRONG        private var _normalFrame:int = 1;                       // frame used in normal resting state        private var _highlightFrame:int = 1;                    // frame used when highlighting        private var _seated:DragItem;                           // DragItem currently seated on this target        private var _autoGrade:Boolean = false;                 // if true DragItem will be graded as soon as seated        private var _rightAnswers:Array = new Array();          // array of possible correct DragItem responses        private var _wrongAnswers:Array;                        // array of wrong DragItem responses, If null, any DragItem an be seated.        private var _shiftPt:Point = new Point();               // (x, y) shift of registration point when animating                public function DropTarget(view:MovieClip = null)         {               super();                        if (! view)             {                _view = this;            }             else             {                _view = view;                x += _view.x;                y += _view.y;                _view.x = 0;                _view.y = 0;                addChild(_view);            }                        // find normal and highlight frames            var normalFrame:int = DragItem.getFrameNumber(_view, "normal");            if (normalFrame)             {                _normalFrame = normalFrame;            }                        var highlightFrame:int = DragItem.getFrameNumber(_view, "highlight");            if (highlightFrame)             {                _highlightFrame = highlightFrame;            }                        state = NORMAL;        }                        // add dragItem to list of correct answers        public function rightAnswer(dragItem:DragItem):void         {            if (_rightAnswers.indexOf(dragItem) == -1)             {                            _rightAnswers.push(dragItem);            }        }                // add dragItem to list of incorrect answers        public function wrongAnswer(dragItem:DragItem):void         {               if (! _wrongAnswers)             {                _wrongAnswers = new Array();            }                        if (isRightResponse(dragItem))             {                throw new Error(dragItem.name + " is already set as a right answer, it can't be both");            }                        if (_wrongAnswers.indexOf(dragItem) == -1)             {                _wrongAnswers.push(dragItem);            }        }                // return true if dragItem is a valid response to this DropTarget        public function isValidResponse(dragItem:DragItem):Boolean         {               if (! _wrongAnswers ||                  // if no wrong answer list all DragItems are valid                          isWrongResponse(dragItem) ||        // if a wrong answer                isRightResponse(dragItem))          // or a right answer            {                        return true;            }            return false;        }                // return true if dragItem is a correct answer        public function isRightResponse(dragItem:DragItem):Boolean         {            return (_rightAnswers.indexOf(dragItem) != -1);        }                // return true if dragItem is a wrong answer        public function isWrongResponse(dragItem:DragItem):Boolean         {               // if no wrong answer list then all DragItems are valid            if (! _wrongAnswers)             {                if (isRightResponse(dragItem))                 {                    return false;                }                 else                 {                    return true;                }            }            return (_wrongAnswers.indexOf(dragItem) != -1);        }                        // seat a DragItem on this DropTarget        //   returns false if DragItem can't be seated        public function seat(dragItem:DragItem):Boolean         {               if (! isValidResponse(dragItem))             {                return false;            }                        if (_seated && _seated != dragItem)             {                // DropTarget already has seated DragItem                return false;            }                        dragItem.unseat();            dragItem.seated = this;            _seated = dragItem;                        if (_autoGrade)             {                Callback.one(dragItem, DragItem.FINISHED_MOVING, grade);            }            dragItem.animateToLoc(x + _shiftPt.x, y + _shiftPt.y);                        return true;        }                // grade any seated DragItem as right or wrong        public function grade():Boolean         {            if (_seated)             {                if (isRightResponse(_seated))                 {                    _seated.state = DragItem.RIGHT;                    return true;                }                 else                 {                    _seated.state = DragItem.WRONG;                }            }            return false;        }                        public function showAnswer(duration:Number = NaN):void         {               if (_seated)             {                // if have seated item                                if (isRightResponse(_seated))                 {                    // reveal seated as correct                    grade();                    return;                }                 else                 {                    // otherwise reset seated item                    _seated.reset(showAnswer);                }            }                        // find available correct answer            for each (var answer:DragItem in _rightAnswers)             {                if (! answer.seated || (answer.seated && answer.seated.isWrongResponse(answer)))                 {                    answer.unseat();                    Callback.one(answer, DragItem.FINISHED_MOVING, grade);                    if (isNaN(duration))                     {                        duration = answer.moveDuration;                    }                                        var temp:uint = answer.moveDuration;                    answer.moveDuration = duration;                    answer.seatOn(this);                    answer.moveDuration = temp;                    return;                }            }        }                // unseat any DragItem from this DropTarget        public function unseat():void         {            var temp:DragItem = _seated;            _seated = null;            if (temp)             {                temp.unseat();            }        }                public function setState(val:String):void         {            _state = val;                        switch (_state)             {                case HIGHLIGHT:                    _view.gotoAndStop(_highlightFrame);                    break;                                default:                    _state = NORMAL;                                    case NORMAL:                    _view.gotoAndStop(_normalFrame);                    break;            }        }                //        // accessors and mutators                public function get dragItem():DragItem                             { return _seated; }        public function get state():String                                  { return _state; }        public function get seated():DragItem                               { return _seated; }        public function get autoGrade():Boolean                             { return _autoGrade; }        public function get shiftPt():Point                                 { return _shiftPt; }        public function get view():MovieClip                                { return _view; }                public function set shiftPt(val:Point):void                         { _shiftPt = val; }        public function set state(val:String):void                          { setState(val); }        public function set autoGrade(val:Boolean):void         {            if (_autoGrade != val)             {                _autoGrade = val;                if (_autoGrade)                 {                    grade();                }            }        }    }}